<p>Harness GitOps lets you perform GitOps deployments in Harness. You define the desired state of the service you want to deploy in your Git manifest, and then use Harness GitOps to sync state with your live Kubernetes cluster.</p><p>This topic describes the basic concepts of Harness GitOps.</p><div class="note-callout">Want to jump right in? Try the <a href="/article/pptv7t53i9-harness-cd-git-ops-quickstart">Harness CD GitOps Quickstart</a>.</div><h3>Harness GitOps Summary</h3><p><strong>What is GitOps?</strong> GitOps is simply using Git to perform Operations Team (Ops) tasks, such as building infrastructure, release automation, and orchestration.</p><p>GitOps is also a way to perform CD using Git as the source of truth for the desired state of the deployment. Architecturally, GitOps uses an operator of some kind to continuously monitor the desired state in Git and and sync it with the live state in the Kubernetes cluster.</p><p>In contrast to using Pipeline steps to perform deployments, GitOps automates deployments by syncing declarative specifications (your manifests) with your target environments. GitOps continually converges the target state (cluster) in accordance with the desired state (manifests). This method turns your deployed applications and infrastructures into fully-traceable, fully-versioned artifacts.</p><p>The declarative description can be in Kubernetes manifest, Helm Charts, Kustomize manifests, and so on.</p><p>The live state can be any microservice or application and its Kubernetes environment.</p><p>Here&#39;s a very simple diagram of the GitOps architecture:</p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/w1vg9l1j7q/1644624710406/clean-shot-2022-02-11-at-16-11-17-2-x.png"/></figure><p>The Harness GitOps Agent is a worker process installed in a Kubernetes cluster. The Agent can be installed in your target cluster or any cluster with connectivity to the target cluster.</p><p>The Harness GitOps Application runs in Harness SaaS and is where you select the source and target resources to use and how to sync them.</p><p>The GitOps Agent makes outbound connections to the GitOps Application in Harness and the Git source repo.</p><p>The GitOps Agent then syncs the desired state of the source manifest with the live state of the cluster.</p><div class="note-callout"><strong>No Cluster-to-Git Push:</strong> in Harness GitOps, the Git manifest is always the source of truth. GitOps does not perform cluster reconciliation (or <em>Self Heal</em>), a process where changes made to the cluster are pushed to the Git source.</div><h4>What Can I Deploy with Harness GitOps?</h4><p>You can deploy any Kubernetes objects. You can deploy services and infrastructure or just bootstrap infrastructure.</p><h4>Harness Platform Integration</h4><p>Harness GitOps takes advantage of all the Harness platform features, such as Access Control, REST APIs, monitoring, auditing, etc.</p><p>The Harness GitOps Agent runs in your environment, but the remaining GitOps features are run in Harness SaaS. You do not need to devote resources to running a frontend for administration or dashboards and Harness manages backend resources other than the Agent.</p><h4>GitOps vs Config-as-Code vs Harness Git Experience</h4><p>Harness has multiple Git-based features and it&#39;s important to understand the differences:</p><ul><li><strong>GitOps:</strong> used for deploying infrastructure and services. The Git commit in a source manifest repo triggers a sync between the desired state in Git and the live cluster state. This can be used to simply bootstrap clusters or for full service deployments.</li><li><strong>Config-as-Code:</strong> Harness supports full YAML-based configuration of Pipelines and other Harness entities like Connectors. Harness Pipeline Studio includes a full YAML IDE with hints and autocomplete, so you can simply code your Pipelines as YAML. See <a href="/article/1eishcolt3-harness-yaml-quickstart">Harness YAML Quickstart</a>.</li><li><strong>Harness Git Experience:</strong> Harness can sync your Pipelines and other entities with Git repos so you can make all your changes in Git instead of, or in addition to, using the Harness Manager UI. See <a href="/article/utikdyxgfz-harness-git-experience-overview">Harness Git Experience Overview</a>.</li></ul><h3>Service</h3><p>A Harness GitOps Service is the same as any other Harness Service.</p><p>A Service represents your microservices and other workloads logically. A Service is a logical entity to be deployed, monitored, or changed independently.</p><h3>Service Instance</h3><p>Service Instances represent the dynamic instantiation of a Service you sync via Harness GitOps.</p><p>For example, for a service representing a Docker image, Service Instances are the number of pods running with the Docker image.</p><p>A single Service can have multiple Service Instances. For example, one for Dev, one for QA, and one for Prod.</p><h3>Environments</h3><p>Harness Environments represent your live environment logically (QA, Prod, etc). In Harness GitOps, an Environment is the live state of the infrastructure.</p><h3>Application</h3><p>GitOps Applications are how you manage GitOps operations for a given desired state and its live instantiation.</p><p>A GitOps Application collects the Repository (what you want to deploy), Cluster (where you want to deploy), and Agent (how you want to deploy). You define these entities and then select them when you set up your Application.</p><p>You will also select:</p><ul><li>Sync Options to define how the Application syncs state.</li><li>Prune Policy for garbage collection of orphaned resources.</li><li>The Source manifest to use (Kubernetes, Helm chart, Kustomization, etc).</li><li>The Destination cluster and namespace.</li></ul><h3>Agent</h3><p>A Harness GitOps Agent is a worker process that runs in your environment, makes secure, outbound connections to Harness SaaS, and performs all the GitOps tasks you request in Harness.</p><p>The Agent uses the Repository and Cluster to connect to source repos and target environments. When you create a Harness GitOps Application, you select the Agent you want to use for these connections and GitOps operations.</p><p>You can run an Agent in your target cluster or in any cluster that has access to your target clusters.</p><p>Agents can deploy to all clusters or you can isolate an Agent in a single cluster. For example, you might have one Agent deploy to Dev and QA environments and another Agent deploy to the production environment.</p><p>Installing an Agent involves setting up an Agent in Harness, downloading its YAML file, and applying the YAML file in a Kubernetes cluster (<code>kubectl apply</code>). Kubernetes then pulls the Harness and ArgoCD images from their respective public repositories.</p><div class="note-callout"><strong>Can I use Harness GitOps images from a local registry?</strong> If you want Kubernetes to pull images from your private registry instead of the public registries, you can simply pull the public images, add then to your local registry, and then update the Agent YAML to use the local registry.</div><h3>Storage</h3><p>All GitOps information is stored on your cluster as ConfigMaps and Secrets. Essentially, the cluster acts as the database for GitOps.</p><p>Your Harness GitOps Application, Repository, Cluster configurations, etc, are all stored on the PersistentVolume of the cluster hosting the Agent.</p><p>Harness SaaS is used to store the state cache only.</p><h3>Cluster</h3><p>A cluster is the target deployment cluster that is compared to the desire state.</p><p>Clusters are synced with the source manifests you add as GitOps Repositories.</p><h3>Repository</h3><p>A Harness GitOps Repository is a repo containing the declarative description of a desired state. The declarative description can be in Kubernetes manifests, Helm Chart, Kustomize manifests, etc.</p><h3>Repository Certificates</h3><p>You can apply a Repository certificate or known host key to a GitOps Agent.</p><p>The GitOps Agent will use the certificate or key for all the connections it makes to repositories.</p><h3>Desired state</h3><p>The desired state of a Service and Environment as represented by files in a Repository.</p><h3>Live state</h3><p>The live state of a Service and Environment. The instantiated microservices and pods that are deployed.</p><h3>Refresh</h3><p>Pulls the latest commit from Git and displays whether the current Sync State is Synced or Out of Sync. It does not sync with the live cluster state.</p><h3>Sync and Sync Status</h3><p>A Sync brings the live state to its desired state by applying changes made in the declarative description.</p><p>Sync Status identifies if the target state is Synched, Out of Sync, or Unknown.</p><h3>Sync Policy</h3><p>Applications react to variations in state between the source manifest and the target cluster using a Sync Policy.</p><p>With Automatic sync enabled, changes to the source manifest initiate sync automatically.</p><p>Synch Options tune the synchronization.</p><h3>Prune Policy</h3><p>Prune Policy tells <a href="https://kubernetes.io/docs/concepts/architecture/garbage-collection/" target="_blank">Kubernetes garbage collection</a> how to check for and delete objects that no longer have owner references.</p><h3>Health and Health Status</h3><p>The health of the Application. Is it syncing correctly (Healthy)?</p><h3>App Diff</h3><p>Compares the latest file in Git with the live state and shows what is different.</p><p>If an Application is Healthy and Synced, then there is no App Diff.</p><h3>GnuPG Keys</h3><p>GnuPG Keys can be used to configure Harness GitOps to only sync against commits that are signed in Git using GnuPG.</p><p>The GitOps Agent you select will enforce signature verification.</p><p></p>