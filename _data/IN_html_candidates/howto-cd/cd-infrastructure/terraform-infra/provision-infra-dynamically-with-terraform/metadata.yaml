type: article
article_id: uznls2lvod
user_id: mfr0nxh4be
category_id: y5cc950ks3
author:
  name: Michael Cretzman
  profile_image: https://www.gravatar.com/avatar/2e8616837f4ee92be5d19ffe9b9ccba9?d=mm&s=150
title: Provision Target Deployment Infra Dynamically with Terraform
slug: provision-infra-dynamically-with-terraform
description: Provision the target deployment infrastructure using the Terraform Plan
  and Apply steps.
short_version: Provision the target deployment infrastructure using the Terraform
  Plan and Apply steps.
tags: []
show_toc: true
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: ""
  source: API
  triggered_at: 2022-09-14T17:43:27.686761Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Provision Target Deployment Infra Dynamically with Terraform
  description: Provision the target deployment infrastructure using the Terraform
    Plan and Apply steps.
  short_version: Provision the target deployment infrastructure using the Terraform
    Plan and Apply steps.
  body: '<p>This topic describes how to provision a CD stage&#39;s target deployment
    infrastructure using the <strong>Terraform Plan</strong> and <strong>Apply</strong>
    steps.</p><p>You use the Terraform steps to run the Terraform script and supporting
    files from your repo. Harness uses the files to create the infrastructure that
    your Pipeline will deploy to.</p><p>Next, you map the script outputs Harness requires
    to target the provisioned infrastructure, such as namespace.</p><p>During deployment,
    Harness provisions the target deployment infrastructure and then the stage&#39;s
    Execution steps deploy to the provisioned infrastructure.</p><div class="note-callout">To
    provision <u>non-target</u> infrastructure, add the Terraform Plan and Apply steps
    to the stage <strong>Execution</strong> section instead of the <strong>Infrastructure</strong>
    section.</div><p></p><h3>Before You Begin</h3><ul><li><a href="/article/boug6e884h-terraform-provisioning-with-harness">Terraform
    Provisioning with Harness</a></li><li><a href="/article/knunou9j30-kubernetes-cd-quickstart">Kubernetes
    CD Quickstart</a></li></ul><h3>Important: Install Terraform on Delegates</h3><p>Terraform
    must be installed on the Delegate to use a Harness Terraform Provisioner. You
    can install Terraform manually or use the <code>INIT_SCRIPT</code> environment
    variable in the Delegate YAML.</p><p>See <a href="/article/yte6x6cyhn-run-scripts-on-delegates">Install
    Software on the Delegate with Initialization Scripts</a>.</p><pre class="hljs
    apache"># Install TF<br/>curl -O -L  https://releases.hashicorp.com/terraform/0.12.25/terraform_0.12.25_linux_amd64.zip<br/>unzip
    terraform_0.12.25_linux_amd64.zip<br/>mv ./terraform /usr/bin/<br/># Check TF
    install<br/>terraform --version</pre><h3>Step 1: Enable Dynamic Provisioning</h3><p>These
    steps assume you&#39;ve created a Harness CD stage before. If Harness CD is new
    to you, see <a href="/article/knunou9j30-kubernetes-cd-quickstart">Kubernetes
    CD Quickstart</a>.</p><p>We&#39;ll start in the stage&#39;s <strong>Infrastructure</strong>
    section because the <strong>Service</strong> settings of the stage don&#39;t have
    specific settings for Terraform provisioning. The Service manifests and artifacts
    will be deployed to the infrastructure provisioned by Harness and Terraform.</p><p>In
    the CD stage, click <strong>Infrastructure</strong>. If you haven&#39;t already
    specified your Environment, and selected the Infrastructure Definition, do so.</p><p>The
    type of Infrastructure Definition you select determines what Terraform outputs
    you&#39;ll need to map later.</p><p>In <strong>Dynamic provisioning</strong>,
    click <strong>Provision your infrastructure dynamically during the execution of
    your pipeline</strong>.</p><p>The default Terraform provisioning steps appear:</p><p></p><figure><img
    src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1627071240009/clean-shot-2021-07-23-at-13-13-50.png"/></figure><p>Harness
    automatically adds the Terraform Plan, <a href="/article/43pzzhrcbv-using-harness-approval-steps-in-cd-stages">Harness
    Approval</a>, and Terraform Apply steps. You can change these steps, but plan,
    approve, and apply is the most common process. We use that process in our Terraform
    documentation.</p><h3>Step 2: Terraform Plan Step</h3><p>The Terraform Plan step
    is where you connect Harness to your repo and add your Terraform scripts.</p><h4>Name</h4><p>In
    <strong>Name</strong>, enter a name for the step, for example, <strong>plan</strong>.</p><p>Harness
    will create an <a href="/article/li0my8tcz3-entity-identifier-reference">Entity
    Id</a> using the name. The Id is very important. It&#39;s used to refer to settings
    in this step.</p><p>For example, if the Id of the stage is <strong>terraform</strong>
    and the Id of the step is <strong>plan</strong>, and you want to echo its timeout
    setting, you would use:</p><p><code>&lt;+pipeline.stages.Terraform.spec.infrastructure.infrastructureDefinition.provisioner.steps.plan.timeout&gt;</code></p><h4>Timeout</h4><p>In
    <strong>Timeout</strong>, enter how long Harness should wait to complete the Terraform
    Plan step before failing the step.</p><h4>Command</h4><p>In <strong>Command</strong>,
    select <strong>Apply</strong>. Even though you are only running a Terraform plan
    in this step, you identify that this step can be used with a Terraform Apply step
    later.</p><h4>Provisioner Identifier</h4><p>Enter a unique value in <strong>Provisioner
    Identifier</strong>.</p><p>The Provisioner Identifier identifies the provisioning
    done in this step. You use the Provisioner Identifier in additional steps to refer
    to the provisioning done in this step.</p><p>The most common use of Provisioner
    Identifier is between the Terraform Plan and Terraform Apply steps. To have the
    Terraform Apply step apply the provisioning from this Terraform Plan step, you
    use the same Provisioner Identifier in both steps.</p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1627076789966/clean-shot-2021-07-23-at-14-46-10.png"/></figure><h5>Provisioner
    Identifier Scope</h5><p>The Provisioner Identifier is a Project-wide setting.
    You can reference it across Pipelines in the same Project.</p><p>For this reason,
    it&#39;s important that all your Project members know the Provisioner Identifiers.
    This will prevent one member building a Pipeline from accidentally impacting the
    provisioning of another member&#39;s Pipeline.</p><h4>Secret Manager</h4><p>Select
    a Secrets Manager to use for encrypting/decrypting and saving the Terraform plan
    file.</p><p>See <a href="/article/hngrlb7rd6-harness-secret-manager-overview">Harness
    Secrets Manager Overview</a>.</p><p>A Terraform plan is a sensitive file that
    could be misused to alter resources if someone has access to it. Harness avoids
    this issue by never passing the Terraform plan file as plain text.</p><p>Harness
    only passes the Terraform plan between the Harness Manager and Delegate as an
    encrypted file using a Secrets Manager.</p><p>When the <code>terraform plan</code> command
    runs on the Harness Delegate, the Delegate encrypts the plan and saves it to the
    Secrets Manager you selected. The encrypted data is passed to the Harness Manager.</p><p>When
    the plan is applied, the Harness Manager passes the encrypted data to the Delegate.</p><p>The
    Delegate decrypts the encrypted plan and applies it using the <code>terraform
    apply</code> command.</p><h4>Configuration File Repository</h4><p><strong>Configuration
    File Repository</strong> is where the Terraform script and files you want to use
    are located.</p><p>Here, you&#39;ll add a connection to the Terraform script repo.</p><p>Click
    <strong>Specify Config File</strong> or edit icon.</p><p>The <strong>Terraform
    Config File Store</strong> settings appear.</p><p>Click the provider where your
    files are hosted.</p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1646170907148/clean-shot-2022-03-01-at-13-41-39.png"/></figure><p></p><p>Select
    or create a Connector for your repo. For steps, see <a href="/article/zbhehjzsnv-connect-to-code-repo">Connect
    to a Git Repo</a> or <a href="/article/euueiiai4m-artifactory-connector-settings-reference">Artifactory
    Connector Settings Reference</a> (see <strong>Artifactory with Terraform Scripts
    and Variable Definitions (.tfvars) Files</strong>).</p><div class="note-callout">If
    you&#39;re simply experimenting, you can use <a href="https://github.com/hashicorp/terraform-provider-kubernetes/tree/main/_examples/gke"
    target="_blank">HashiCorp&#39;s Kubernetes repo</a>.</div><h4>Git Providers</h4><p>In
    <strong>Git Fetch Type</strong>, select <strong>Latest from Branch</strong> or
    <strong>Specific Commit ID</strong>. When you run the Pipeline, Harness will fetch
    the script from the repo.</p><div class="note-callout"><strong>Specific Commit
    ID</strong> also supports <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging"
    target="_blank">Git tags</a>.</div><p>If you think the script might change often,
    you might want to use <strong>Specific Commit ID</strong>. For example, if you
    are going to be fetching the script multiple times in your Pipeline, Harness will
    fetch the script each time. If you select <strong>Latest from Branch</strong>
    and the branch changes between fetches, different scripts are run.</p><p>In <strong>Branch</strong>,
    enter the name of the branch to use.</p><p>In <strong>Folder Path</strong>, enter
    the path from the root of the repo to the folder containing the script.</p><p>For
    example, here&#39;s a Terraform script repo, the Harness Connector to the repo,
    and the <strong>Config Files</strong> settings for the branch and folder path:</p><p></p><figure><img
    src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1627332955547/clean-shot-2021-07-26-at-13-55-35.png"/></figure><p></p><p>Click
    <strong>Submit</strong>.</p><p>Your Terraform Plan step is now ready. You can
    now configure the Terraform Apply step that will inherit the Terraform script
    and settings from this Terraform Plan step.</p><p>You can jump ahead to the Terraform
    Apply step below. The following sections cover common Terraform Plan step options.</p><h4>Artifactory</h4><p>See
    <a href="/article/euueiiai4m-artifactory-connector-settings-reference">Artifactory
    Connector Settings Reference</a> (see <strong>Artifactory with Terraform Scripts
    and Variable Definitions (.tfvars) Files</strong>).</p><h4>Source Module</h4><p>When
    you set up the file repo in <strong>Configuration File Repository</strong>, you
    use a Harness Connector to connect to the repo where the Terraform scripts are
    located.</p><p>Some scripts will reference module sources in other repos and Harness
    will pull the source code for the desired child module at runtime (during <code>terraform
    init</code>).</p><p>In <strong>Source Module</strong>, you can select <strong>Use
    Connector credentials</strong> to have Harness use the credentials of the Connector
    to pull the source code for the desired child module(s).</p><p>If you do not select
    <strong>Use Connector credentials</strong>, Terraform will use the credentials
    that have been set up in the system.</p><div class="note-callout">The <strong>Use
    Connector credentials</strong> setting is limited to Harness Git Connectors using
    SSH authentication (not HTTPS) and a token.</div><h3>Option: Workspace</h3><p>Harness
    supports Terraform <a href="https://www.terraform.io/docs/state/workspaces.html">workspaces</a>.
    A Terraform workspace is a logical representation of one your infrastructures,
    such as Dev, QA, Stage, Production.</p><p>Workspaces are useful when testing changes
    before moving to a production infrastructure. To test the changes, you create
    separate workspaces for Dev and Production.</p><p>A workspace is really a different
    state file. Each workspace isolates its state from other workspaces. For more
    information, see <a href="https://www.terraform.io/docs/state/workspaces.html#when-to-use-multiple-workspaces"
    target="_blank">When to use Multiple Workspaces</a> from Hashicorp.</p><p>Here&#39;s
    an example script where a local value names two workspaces, <strong>default</strong>
    and <strong>production</strong>, and associates different instance counts with
    each:</p><pre class="hljs json">locals {<br/>  counts = {<br/>      &#34;default&#34;=1<br/>      &#34;production&#34;=3<br/>  }<br/>}<br/><br/>resource
    &#34;aws_instance&#34; &#34;my_service&#34; {<br/>  ami=&#34;ami-7b4d7900&#34;<br/>  instance_type=&#34;t2.micro&#34;<br/>  count=&#34;${lookup(local.counts,
    terraform.workspace, 2)}&#34;<br/>  tags {<br/>         Name = &#34;${terraform.workspace}&#34;<br/>    }<br/>}</pre><p></p><p>In
    the workspace interpolation sequence, you can see the count is assigned by applying
    it to the Terraform workspace variable (<code>terraform.workspace</code>) and
    that the tag is applied using the variable also.</p><p>Harness will pass the workspace
    name you provide to the <code>terraform.workspace</code> variable, thus determining
    the count. If you provide the name <strong>production</strong>, the count will
    be <strong>3</strong>.</p><p>In the <strong>Workspace</strong> setting, you can
    simply select the name of the workspace to use.</p><p>You can also use a <a href="/article/lml71vhsim-harness-variables">stage
    variable</a> in <strong>Workspace</strong>.</p><p>Later, when the Pipeline is
    deployed, you specify the value for the stage variable and it is used in <strong>Workspace</strong>.</p><p>This
    allows you to specify a different workspace name each time the Pipeline is run.</p><p>You
    can even set a Harness Trigger where you can set the workspace name used in <strong>Workspace</strong>.</p><h3>Option:
    Terraform Var Files</h3><p>The <strong>Terraform Var Files</strong> section is
    for entering and/or linking to Terraform script Input variables.</p><p>You can
    use inline or remote var files.</p><p>Harness supports all <a href="https://www.terraform.io/docs/language/expressions/types.html"
    target="_blank">Terraform input types and values</a>.</p><h4>Inline Variables</h4><p>You
    can add inline variables just like you would in a tfvar file.</p><p>Click <strong>Add
    Terraform Var File</strong>, and then click <strong>Add Inline</strong>.</p><p>The
    <strong>Add Inline Terraform Var File</strong> settings appear.</p><p>In <strong>Identifier</strong>,
    enter an identifier so you can refer to variables using expressions if needed.</p><div
    class="note-callout">This Identifier is a <a href="/article/li0my8tcz3-entity-identifier-reference">Harness
    Identifier</a>, not a Terraform identifier.</div><p>For example, if the <strong>Identifier</strong>
    is <strong>myvars</strong> you could refer to its content like this:</p><p><code>&lt;+pipeline.stages.MyStage.spec.infrastructure.infrastructureDefinition.provisioner.steps.plan.spec.configuration.varFiles.myvars.spec.content&gt;</code></p><p>Provide
    the input variables and values for your Terraform script. Harness follows the
    same format as Terraform.</p><p>For example, if your Terraform script has the
    following:</p><pre>variable &#34;region&#34; {<br/>  type = string<br/>}</pre><p></p><p>In
    <strong>Add Inline Terraform Var File</strong>, you could enter:</p><pre>region
    = &#34;asia-east1-a&#34;</pre><p></p><h5>Inline Variable Secrets</h5><p>If you
    are entering secrets (for credentials, etc.), use Harness secret references in
    the value of the variable:</p><pre>secrets_encryption_kms_key = &#34;&lt;+secrets.getValue(&#34;org.kms_key&#34;)&gt;&#34;</pre><p></p><p>See
    <a href="/article/osfw70e59c-add-use-text-secrets">Add Text Secrets</a>.</p><h4>Remote
    Variables</h4><p>You can connect Harness to remote variable files.</p><p>Click
    <strong>Add Terraform Var File</strong>, and then click <strong>Add Remote</strong>.</p><p>Select
    your Git provider (GitHub, etc.) and then select or create a Connector to the
    repo where the files are located. Typically, this is the same repo where your
    Terraform script is located, so you can use the same Connector.</p><p>Click <strong>Continue</strong>.
    The <strong>Var File Details</strong> settings appear.</p><p></p><figure><img
    src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1627336021033/clean-shot-2021-07-26-at-14-46-52.png"/></figure><p></p><p>In
    <strong>Identifier</strong>, enter an identifier so you can refer to variables
    using expressions if needed.</p><p>For example, if the <strong>Identifier</strong>
    is <strong>myremotevars</strong> you could refer to its content like this:</p><p><code>&lt;+pipeline.stages.MyStage.spec.infrastructure.infrastructureDefinition.provisioner.steps.plan.spec.configuration.varFiles.myremotevars.spec.store.spec.paths&gt;</code></p><p>In
    <strong>Git Fetch Type</strong>, select <strong>Latest from Branch</strong> or
    <strong>Specific Commit ID</strong>.</p><p>In <strong>Branch</strong>, enter the
    name of the branch.</p><p>In <strong>File Paths</strong>, add one or more file
    paths from the root of the repo to the variable file.</p><p>Click <strong>Submit</strong>.
    The remote file(s) are added.</p><h5>Artifactory</h5><p>See <a href="/article/euueiiai4m-artifactory-connector-settings-reference">Artifactory
    Connector Settings Reference</a> (see <strong>Artifactory with Terraform Scripts
    and Variable Definitions (.tfvars) Files</strong>).</p><h3>Option: Backend Configuration</h3><p>The
    <strong>Backend Configuration</strong> section contains the <a href="https://www.terraform.io/docs/language/state/remote.html">remote
    state</a> values.</p><p>Enter values for each backend config (remote state variable).</p><p>For
    example, if your config.tf file has the following backend:</p><pre class="hljs
    json">terraform {<br/>  backend &#34;gcs&#34; {<br/>    bucket  = &#34;tf-state-prod&#34;<br/>    prefix  =
    &#34;terraform/state&#34;<br/>  }<br/>}</pre><p></p><p>In <strong>Backend Configuration</strong>,
    you provide the required configuration variables for that backend type. See <strong>Configuration
    variables</strong> in Terraform&#39;s <a href="https://www.terraform.io/docs/language/settings/backends/gcs.html#configuration-variables"
    target="_blank">gcs Standard Backend doc</a>.</p><p>You can use Harness secrets
    for credentials. See <a href="/article/osfw70e59c-add-use-text-secrets">Add Text
    Secrets</a>.</p><h3>Option: Targets</h3><p>You can use the <strong>Targets</strong>
    setting to target one or more specific modules in your Terraform script, just
    like using the <code>terraform plan -target</code> command. See <a href="https://www.terraform.io/docs/commands/plan.html#resource-targeting"
    target="_blank">Resource Targeting</a> from Terraform.</p><p>You simply identify
    the module using the standard format <code>module.name</code>, like you would
    using <code>terraform plan -target=&#34;module.s3_bucket&#34;</code>.</p><div
    class="note-callout">If you have multiple modules in your script and you don&#39;t
    select one in <strong>Targets</strong>, all modules are used.</div><p></p><h3>Option:
    Environment Variables</h3><p>If your Terraform script uses <a href="https://www.terraform.io/docs/cli/config/environment-variables.html"
    target="_blank">environment variables</a>, you can provide values for those variables
    here.</p><p>For example:</p><pre>TF_LOG_PATH=./terraform.log<br/>TF_VAR_alist=&#39;[1,2,3]&#39;</pre><p></p><p>You
    can use Harness encrypted text for values. See <a href="/article/osfw70e59c-add-use-text-secrets">Add
    Text Secrets</a>.</p><h3>Option: Advanced Settings</h3><p>In <strong>Advanced</strong>,
    you can use the following options:</p><ul><li><a href="/article/i36ibenkq2-step-skip-condition-settings">Step
    Skip Condition Settings</a></li><li><a href="/article/htrur23poj-step-failure-strategy-settings">Step
    Failure Strategy Settings</a></li><li><a href="/article/nnuf8yv13o-select-delegates-with-selectors">Select
    Delegates with Selectors</a></li></ul><h3>Step 3: Approval Step</h3><p>By default,
    Harness adds an Approval step between the Terraform Plan and Terraform Apply steps.
    You can remove this step or follow the steps in <a href="/article/43pzzhrcbv-using-harness-approval-steps-in-cd-stages">Using
    Manual Harness Approval Steps in CD Stages</a> to configure the step.</p><p>You
    can also use a Jira Approval step. See <a href="/article/2lhfk506r8-adding-jira-approval-stages">Adding
    Jira Approval Stages and Steps</a>.</p><h3>Step 4: Terraform Apply Step</h3><p>The
    Terraform Apply step simply inherits its configuration from the Terraform Plan
    step you already configured.</p><p>As stated earlier, you use the same <strong>Provisioner
    Identifier</strong> in the Terraform Plan and Terraform Apply steps:</p><p></p><figure><img
    src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1627076789966/clean-shot-2021-07-23-at-14-46-10.png"/></figure><p>In
    Terraform Apply, enter a name for the step. The name is very important, as you&#39;ll
    use it to select the outputs from the Terraform apply operation.</p><p>You&#39;ll
    use the outputs when mapping the provisioned infrastructure to the target Infrastructure
    Definition.</p><p>For example, if you name the Terraform Apply step <strong>apply123</strong>
    and you want to reference the <strong>region</strong> output in your script, you&#39;d
    use the expression:</p><p><code>&lt;+infrastructureDefinition.provisioner.steps.apply123.output.region&gt;</code></p><p>The
    mapping is explained in the next step.</p><p>In <strong>Timeout</strong>, enter
    how long Harness should wait to complete the Terraform Apply step before failing
    the step.</p><p>In <strong>Configuration Type</strong>, select <strong>Inherit
    From Plan</strong>. If you select <strong>Inline</strong>, then you aren&#39;t
    using the previous Terraform Plan step. You are entering separate Terraform files
    and settings.</p><p>In <strong>Provisioner Identifier</strong>, enter the same
    Provisioner Identifier you entered in the Terraform Plan step.</p><p>Click <strong>Apply
    Changes</strong>.</p><h3>Step 5: Map Outputs to Target Infra Settings</h3><p>Now
    that the Terraform Plan and Terraform Apply steps are set up in <strong>Dynamic
    provisioning</strong>, Harness is configured to provision the infrastructure defined
    in your Terraform script.</p><p>Next, in the <strong>Infrastructure Definition</strong>,
    you need to provide the required Infrastructure Definition settings so Harness
    can <u>target</u> and deploy to the provisioned infrastructure.</p><p>The required
    settings are specific outputs from your Terraform script. Which settings are required
    depends on the type of target infrastructure you are provisioning/targeting.</p><p>For
    example, a platform-agnostic Kubernetes cluster infrastructure only requires the
    target namespace in the target cluster.</p><p>Gather the following:</p><ul><li>The
    name you gave the Terraform Apply step.</li><li>The names of the required outputs
    from your Terraform script.</li></ul><p>Create the FQN expression for each output.</p><p>The
    expressions follow the format:</p><p><code>&lt;+infrastructureDefinition.provisioner.steps.[Apply
    Step Id].output.[output name]&gt;</code></p><p>For example, for a Kubernetes deployment,
    you need to map the <code>namespace</code> output to the <strong>Namespace</strong>
    setting in Infrastructure Definition.</p><p>So for a Terraform Apply step with
    the Id <strong>apply123</strong> and an output named <strong>namespace</strong>,
    the expression is:</p><p><code>&lt;+infrastructureDefinition.provisioner.steps.apply123.output.namespace&gt;</code></p><p>Here
    you can see how the expression is created from the Terraform Apply step name and
    the Terraform script (output.tf, config.tf, etc):</p><p>Use the expressions to
    map the outputs in the required Infrastructure Definition settings, such as <strong>namespace</strong>
    in <strong>Cluster Details</strong>.</p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1627342185162/clean-shot-2021-07-26-at-16-29-34.png"/></figure><p>Now
    Harness has the provisioned target infrastructure set up.</p><p>You can complete
    your Pipeline and then run it.</p><p>Harness will provision the target infrastructure
    and then deploy to it.</p><h3>Step 6: Terraform Rollback</h3><p>The <strong>Terraform
    Rollback</strong> step is automatically added to the <strong>Rollback</strong>
    section.</p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1627413855931/clean-shot-2021-07-27-at-12-23-59.png"/></figure><p>Open
    <strong>Terraform Rollback</strong>.</p><p>Enter a name for the step.</p><p>In
    <strong>Provisioner Identifier</strong>, enter the same Provisioner Identifier
    you used in the Terraform Plan and Apply steps.</p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/uznls2lvod/1627421713483/clean-shot-2021-07-27-at-14-34-48.png"/></figure><p>Click
    <strong>Apply Changes</strong>.</p><p>When rollback happens, Harness rolls back
    the provisioned infrastructure to the previous successful version of the Terraform
    state.</p><p>Harness won&#39;t increment the serial in the state, but perform
    a hard rollback to the exact version of the state provided.</p><p>Harness determines
    what to rollback using the <strong>Provisioner Identifier</strong>.</p><p>If you&#39;ve
    made these settings expressions, Harness uses the values it obtains at runtime
    when it evaluates the expression.</p><h4 id="undefined">Rollback Limitations</h4><p>Let&#39;s
    say you deployed two modules successfully already: module1 and module2. Next,
    you try to deploy module3, but deployment failed. Harness will roll back to the
    successful state of module1 and module2.</p><p>However, let&#39;s look at the
    situation where module3 succeeds and now you have module1, module2, and module3
    deployed. If the next deployment fails, the rollback will only roll back to the
    Terraform state with module3 deployed. Module1 and module2 weren&#39;t in the
    previous Terraform state, so the rollback excludes them.</p><h3>See Also</h3><ul><li><a
    href="/article/hdclyshiho-run-a-terraform-plan-with-the-terraform-apply-step">Apply
    a Terraform Plan with the Terraform Apply Step</a></li></ul><p></p>'
  slug: provision-infra-dynamically-with-terraform
  tags: []
  is_live: true
