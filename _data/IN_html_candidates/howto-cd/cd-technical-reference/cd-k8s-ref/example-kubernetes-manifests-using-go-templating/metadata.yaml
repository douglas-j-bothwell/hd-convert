type: article
article_id: qvlmr4plcp
user_id: mfr0nxh4be
category_id: 85tr1q4hin
author:
  name: Michael Cretzman
  profile_image: https://www.gravatar.com/avatar/2e8616837f4ee92be5d19ffe9b9ccba9?d=mm&s=150
title: Example Kubernetes Manifests using Go Templating
slug: example-kubernetes-manifests-using-go-templating
description: To make your Kubernetes manifest reusable and dynamic, you can use Go
  templating and Harness built-in variables in combination in your Manifests files.
  This topic shows some common examples and best…
short_version: To make your Kubernetes manifest reusable and dynamic, you can use
  Go templating and Harness built-in variables in combination in your Manifests files.
  This topic shows some common examples and best…
tags: []
show_toc: false
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: ""
  source: API
  triggered_at: 2022-08-31T21:29:10.549354Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Example Kubernetes Manifests using Go Templating
  description: ""
  short_version: ""
  body: '<p>To make your Kubernetes manifest reusable and dynamic, you can use <a
    href="https://godoc.org/text/template" target="_blank">Go templating</a> and Harness
    built-in variables in combination in your <strong>Manifests</strong> files.</p><p>This
    topic shows some common examples and best practices.</p><h3>Basic Values YAML
    and Manifests for Public Image</h3><p>This is a simple example using the Artifact
    reference <code>&lt;+artifact.image&gt;</code>. It can be used whenever the public
    image is not hardcoded in manifests.</p><p>See <a href="/article/4ifq51cp0i-add-artifacts-for-kubernetes-deployments">Add
    Container Images as Artifacts for Kubernetes Deployments</a>.</p><p>We use Go
    templates with a values.yaml file and manifests for deployment, namespace, and
    service. The manifests for deployment, namespace, and service are in a <strong>templates</strong>
    folder that&#39;s a peer of the values.yaml file.</p><h5>values.yaml</h5><p>This
    file uses the <code>image: &lt;+artifact.image&gt;</code> to identify the primary
    artifact added in the Harness Service Definition <strong>Artifacts</strong> section.</p><p>It
    also uses <code>name: &lt;+stage.name&gt;</code> to reference a Stage variable
    <code>name</code> and <code>namespace: &lt;+infra.namespace&gt;</code> to reference
    the namespace entered in the Stage&#39;s <strong>Infrastructure Definition</strong>.
    Service type and ports are hardcoded.</p><p>The name, image, and namespace values
    are referenced in the manifests described later.</p><pre class="hljs yaml">name:
    &lt;+stage.name&gt;<br/>replicas: 2<br/><br/>image: &lt;+artifact.image&gt;<br/>#
    dockercfg: &lt;+artifact.imagePullSecret&gt;<br/><br/>createNamespace: true<br/>namespace:
    &lt;+infra.namespace&gt;<br/><br/># Service Type allow you to specify what kind
    of service you want.<br/># Possible values for ServiceType are:<br/># ClusterIP
    | NodePort | LoadBalancer | ExternalName<br/>serviceType: LoadBalancer<br/><br/>#
    A Service can map an incoming port to any targetPort.<br/># targetPort is where
    application is listening on inside the container.<br/>servicePort: 80<br/>serviceTargetPort:
    80<br/><br/># Specify all environment variables to be added to the container.<br/>#
    The following two maps, config and secrets, are put into a ConfigMap<br/># and
    a Secret, respectively.<br/># Both are added to the container environment in podSpec
    as envFrom source.<br/>env:<br/>  config:<br/>    key1: value10<br/>  secrets:<br/>    key2:
    value2</pre><p></p><h5>templates/deployment.yaml</h5><p>The deployments manifest
    references the name and image values from values.yaml. The manifest also contains
    the ConfigMap and Secret objects.</p><pre class="hljs yaml">{{- if .Values.env.config}}<br/>apiVersion:
    v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: {{.Values.name}}<br/>data:<br/>{{.Values.env.config
    | toYaml | indent 2}}<br/>---<br/>{{- end}}<br/><br/>{{- if .Values.env.secrets}}<br/>apiVersion:
    v1<br/>kind: Secret<br/>metadata:<br/>  name: {{.Values.name}}<br/>stringData:<br/>{{.Values.env.secrets
    | toYaml | indent 2}}<br/>---<br/>{{- end}}<br/><br/>{{- if .Values.dockercfg}}<br/>apiVersion:
    v1<br/>kind: Secret<br/>metadata:<br/>  name: {{.Values.name}}-dockercfg<br/>  annotations:<br/>    harness.io/skip-versioning:
    true<br/>data:<br/>  .dockercfg: {{.Values.dockercfg}}<br/>type: kubernetes.io/dockercfg<br/>---<br/>{{-
    end}}<br/><br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name:
    {{.Values.name}}-deployment<br/>spec:<br/>  replicas: {{int .Values.replicas}}<br/>  selector:<br/>    matchLabels:<br/>      app:
    {{.Values.name}}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app:
    {{.Values.name}}<br/>    spec:<br/>      {{- if .Values.dockercfg}}<br/>      imagePullSecrets:<br/>      -
    name: {{.Values.name}}-dockercfg<br/>      {{- end}}<br/>      containers:<br/>      -
    name: {{.Values.name}}<br/>        image: {{.Values.image}}<br/>        {{- if
    or .Values.env.config .Values.env.secrets}}<br/>        envFrom:<br/>        {{-
    if .Values.env.config}}<br/>        - configMapRef:<br/>            name: {{.Values.name}}<br/>        {{-
    end}}<br/>        {{- if .Values.env.secrets}}<br/>        - secretRef:<br/>            name:
    {{.Values.name}}<br/>        {{- end}}<br/>        {{- end}}</pre><p></p><h5>templates/namespace.yaml</h5><p>The
    namespace manifest references the namespace value from values.yaml.</p><pre class="hljs
    yaml">{{- if .Values.createNamespace}}<br/>apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name:
    {{.Values.namespace}}<br/>{{- end}}</pre><p></p><h5>templates/service.yaml</h5><p>The
    service manifest references the hardcoded service type and ports from values.yaml.</p><pre
    class="hljs yaml">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: {{.Values.name}}-svc<br/>spec:<br/>  type:
    {{.Values.serviceType}}<br/>  ports:<br/>  - port: {{.Values.servicePort}}<br/>    targetPort:
    {{.Values.serviceTargetPort}}<br/>    protocol: TCP<br/>  selector:<br/>    app:
    {{.Values.name}}</pre><p></p><h3>Private Artifact Example</h3><p>When the image
    is in a private repo, you use the expression <code>&lt;+artifact.imagePullSecret&gt;</code> in
    the Secret and Deployment objects in your manifest.</p><p>This key will import
    the credentials from the Docker credentials file in the artifact.</p><p>It&#39;s
    much simpler to simple use the <code>&lt;+artifact.imagePullSecret&gt;</code>
    expression in the values.yaml file and then reference it in other manifests.</p><p>Using
    the values.yaml file above, we simply remove the comment in front of <code>dockercfg:
    &lt;+artifact.imagePullSecret&gt;</code>:</p><pre class="hljs yaml">name: &lt;+stage.name&gt;<br/>replicas:
    2<br/><br/>image: &lt;+artifact.image&gt;<br/>dockercfg: &lt;+artifact.imagePullSecret&gt;<br/><br/>createNamespace:
    true<br/>namespace: &lt;+infra.namespace&gt;<br/>...</pre><p></p><p>You don&#39;t
    need to make changes to the deployment manifest from earlier. It uses Go templating
    to check for the <code>dockercfg</code> value in values.yaml and applies it to
    Secret and Deployment.</p><p>If using the condition <code>{{- if .Values.dockercfg}}</code>
    to check for <code>dockercfg</code> in values.yaml.</p><pre>...<br/>{{- if .Values.dockercfg}}<br/>apiVersion:
    v1<br/>kind: Secret<br/>metadata:<br/>  name: {{.Values.name}}-dockercfg<br/>  annotations:<br/>    harness.io/skip-versioning:
    true<br/>data:<br/>  .dockercfg: {{.Values.dockercfg}}<br/>type: kubernetes.io/dockercfg<br/>---<br/>{{-
    end}}<br/><br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name:
    {{.Values.name}}-deployment<br/>spec:<br/>  replicas: {{int .Values.replicas}}<br/>  selector:<br/>    matchLabels:<br/>      app:
    {{.Values.name}}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app:
    {{.Values.name}}<br/>    spec:<br/>      {{- if .Values.dockercfg}}<br/>      imagePullSecrets:<br/>      -
    name: {{.Values.name}}-dockercfg<br/>      {{- end}}<br/>      containers:<br/>      -
    name: {{.Values.name}}<br/>        image: {{.Values.image}}<br/>...</pre><p></p><p></p><h3>Quotation
    Marks</h3><p>The following example puts quotations around whatever string is in
    the <code>something</code> value. This can handle values that could otherwise
    be interpreted as numbers, or empty values, which would cause an error.</p><pre>{{.Values.something
    | quote}}</pre><p>You should use single quotes if you are using a value that might
    contain a YAML-like structure that could cause issues for the YAML parser.</p><h3>Verbatim</h3><p>Use
    <code>indent</code> and <code>toYaml</code> to put something from the values file
    into the manifest verbatim.</p><pre>{{.Values.env.config | toYaml | indent 2}}</pre><h3>Indexing
    Structures in Templates</h3><p>If the data passed to the template is a map, slice,
    or array it can be indexed from the template.</p><p>You can use <code>{{index
    x number}}</code> where <code>index</code> is the keyword, <code>x</code> is the
    data, and <code>number</code> is an integer for the <code>index</code> value.</p><p>If
    we had <code>{{index names 2}}</code> it is equivalent to <code>names[2]</code>.
    We can add more integers to index deeper into data. <code>{{index names 2 3 4}}</code>
    is equivalent to <code>names[2][3][4]</code>.</p><p>Let&#39;s look at an example:</p><pre>{{-
    if .Values.env.config}}<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>
    name: {{.Values.name}}-{{.Values.track}}<br/> labels:<br/> app: {{.Values.name}}<br/>
    track: {{.Values.track}}<br/> annotations:<br/> harness.io/skip-versioning: &#34;true&#34;<br/>data:<br/>{{-
    if hasKey .Values.env .Values.track}}<br/>{{index .Values.env .Values.track &#34;config&#34;
    | mergeOverwrite .Values.env.config | toYaml | indent 2}}<br/>{{- else }}<br/>{{.Values.env.config
    | toYaml | indent 2}}<br/>{{- end }}<br/>---<br/>{{- end}}<br/><br/>{{- if .Values.env.secrets}}<br/>apiVersion:
    v1<br/>kind: Secret<br/>metadata:<br/> name: {{.Values.name}}-{{.Values.track}}<br/>
    labels:<br/> app: {{.Values.name}}<br/> track: {{.Values.track}}<br/>stringData:<br/>{{-
    if hasKey .Values.env .Values.track}}<br/>{{index .Values.env .Values.track &#34;secrets&#34;
    | mergeOverwrite .Values.env.secrets | toYaml | indent 2}}<br/>{{- else }}<br/>{{.Values.env.secrets
    | toYaml | indent 2}}<br/>{{- end }}<br/>---<br/>{{- end}}</pre><p></p><h3 id="undefined">Option:
    Skip Rendering of Manifest Files</h3><p>In some cases, you might not want to use
    Go templating because your manifests use some other formatting.</p><p>Use the <strong>Skip
    Rendering K8s manifest files</strong> option in the <a href="https://docs.harness.io/article/4vjgmjcj6z">Kubernetes
    Apply</a> step if you want Harness to skip rendering your manifest files using
    Go templating.</p><h3>Notes</h3><ul><li><a href="/article/lml71vhsim-harness-variables">Harness
    Variables and Expressions</a> may be added to values.yaml, not the manifests themselves.
    This provides more flexibility.</li><li>The values.yaml file used in a stage Service
    doesn&#39;t support Helm templating, only Go templating. Helm templating is fully
    supported in the <u>remote</u> Helm charts you add to your Service.</li><li>Harness
    uses Go template version 0.4. If you&#39;re used to Helm templates, you can download
    Go template and try it out locally to find out if your manifests will work. This
    can help you avoid issues when adding your manifests to Harness.<br/>You can install
    Go template version 0.4 locally to test your manifests.<ul><li>Mac OS: curl -O
    https://app.harness.io/public/shared/tools/go-template/release/v0.4/bin/darwin/amd64/go-template</li><li>Linux:
    curl -O https://app.harness.io/public/shared/tools/go-template/release/v0.4/bin/linux/amd64/go-template</li><li>Windows:
    curl -O https://app.harness.io/public/shared/tools/go-template/release/v0.4/bin/windows/amd64/go-template</li></ul>For
    steps on doing local Go templating, see <a href="https://community.harness.io/t/harness-local-go-templating/460"
    target="_blank">Harness Local Go-Templating</a> on Harness Community.</li><li>Harness
    uses an internal build of Go templating. It cannot be upgraded. Harness uses <a
    href="http://masterminds.github.io/sprig/" target="_blank">Spring templates functions</a>,
    excluding those functions that provide access to the underlying OS (env, expandenv)
    for security reasons.<br/>In addition, Harness uses the functions ToYaml, FromYaml,
    ToJson, FromJson.</li></ul><p></p><p></p>'
  slug: example-kubernetes-manifests-using-go-templating
  tags: []
  is_live: true
