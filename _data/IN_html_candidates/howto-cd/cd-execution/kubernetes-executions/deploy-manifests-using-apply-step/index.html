<p>By default, the Harness Kubernetes Rolling, Canary, and Blue Green steps will deploy all of the resources you have set up in the Service Definition <strong>Manifests</strong> section.</p><p>In some cases, you might have resources in <strong>Manifests</strong> that you do not want to deploy as part of the main deployment, but want to apply as another step in the stage.</p><p>For example, you might want to deploy an additional resource only after Harness has verified the deployment of the main resources in the <strong>Manifests</strong> section.</p><p>CD stages include an <strong>Apply</strong> step that allows you to deploy any resource you have set up in the <strong>Manifests</strong> section.</p><h3>Before You Begin</h3><ul><li><a href="/article/ssbq0xh0hx-define-kubernetes-manifests">Add Kubernetes Manifests</a></li><li><a href="/article/knunou9j30-kubernetes-cd-quickstart">Kubernetes CD Quickstart</a></li></ul><h3 id="what_kubernetes_workloads_can_i_include">What Kubernetes Workloads Can I Include?</h3><p>The <strong>​Apply Step</strong> can deploy all workload types, including Jobs.</p><p>All workloads deployed by the Apply step are managed workloads. Managed workloads are tracked until steady state is reached.</p><div class="note-callout">The Apply Step is primarily used for deploying Jobs controllers, but it can be used for other resources. Typically, when you want to deploy multiple workloads (Deployment, StatefulSet, and DaemonSet) you will use separate stages for each.</div><p>Other Kubernetes steps, such as Rolling, are limited to specific workload types.</p><p>For a detailed list of what Kubernetes workloads you can deploy in Harness, see <a href="/article/efnlvytc6l-what-can-i-deploy-in-kubernetes">What Can I Deploy in Kubernetes?</a>.</p><h4>Rolling vs Apply</h4><p>The following table lists the differences between the Rolling Deployment step (default in a Rolling strategy) and the Apply step (which may be used with any strategy).</p><table><tbody><tr><td><p></p></td><td><p><strong>Jobs</strong></p></td><td><p><strong>Rollback</strong></p></td></tr><tr><td><p><strong>Rolling Deployment step</strong></p></td><td><p>No</p></td><td><p>Yes</p></td></tr><tr><td><p><strong>Apply step</strong></p></td><td><p>Yes</p></td><td><p>No</p></td></tr></tbody></table><p></p><p></p><h3>Step 1: Skip a Specific Workload</h3><p>By default, when you run a CD Pipeline, Harness will use all of the manifests in the <strong>Manifests</strong> section, and deploy all of its workloads.</p><p>To avoid having a specific workload deployed as part of the standard deployment, you add the Harness comment  <code># harness.io/skip-file-for-deploy</code> to the <strong>top</strong> of the file.</p><p>This comment instructs Harness to ignore this manifest. Later, you will use the <strong>Apply Step</strong> to deploy this manifest.</p><p>For example, here is a ConfigMap file using the <code># harness.io/skip-file-for-deploy</code> comment:</p><pre># harness.io/skip-file-for-deploy<br/><br/>{{- if .Values.env.config}}<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: {{.Values.name}}<br/>data:<br/>{{.Values.env.config | toYaml | indent 2}}<br/>---<br/>{{- end}}</pre><p></p><p>Now, when this Pipeline is executed, this ConfigMap resource will not be applied.</p><h4>Important</h4><ul><li>The comment <code># harness.io/skip-file-for-deploy</code> must be at the <strong>top</strong> of the file. If it is on the second line it will not work and the resource will be deployed as part of the main stage rollout.</li><li>If you apply the ignore comment <code># harness.io/skip-file-for-deploy</code> to a resource but do not use the resource in an <strong>Apply</strong> step, the resource is never deployed.</li></ul><h3>Step 2: Add the Manifest</h3><p>Add the commented manifest to the <strong>Manifests</strong> section of your CD stage.</p><p>See <a href="/article/ssbq0xh0hx-define-kubernetes-manifests">Add Kubernetes Manifests</a>.</p><h3>Step 3: Add the Apply Step</h3><p>In your Pipeline, click <strong>Add Step</strong>, and then click <strong>Apply</strong>. The Apply step appears.</p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/00el61pzok/1626903072396/clean-shot-2021-07-21-at-14-31-04.png"/></figure><p>Enter a name for the step. Harness will create a step Id using the name, but you can change it.</p><p></p><h3>Step 4: Enter the Path and Name of the Manifest</h3><p>In <strong>File Path</strong>, enter the path to a manifest file.</p><p><strong>File Path</strong> has the following requirements:</p><ul><li>The path to the manifest for the Apply step must be subordinate to the path for the manifest in the <strong>Manifests</strong> section of the Service Definition. The manifest cannot be in the same folder as <strong>Manifests</strong>.</li><li>The path must include the folder name and the file name.</li></ul><p>In the following example, the path used in the <strong>Manifests</strong> section of the Service Definition is <code>default-k8s-manifests/Manifests/Files/templates/</code>. The <strong>Apply</strong> step uses a Job manifest in the subfolder <code>jobs/job.yaml</code>.</p><p></p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/00el61pzok/1626913892295/clean-shot-2021-07-21-at-17-31-19.png"/></figure><p>You can enter multiple file paths in File Path. Simply click <strong>Add file</strong>.</p><h4>File Path Runtime Inputs</h4><p>You can set <a href="/article/f6yobn7iq0-runtime-inputs">Fixed Values, Runtime Inputs, and Expressions</a> for File Path settings:</p><p></p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/00el61pzok/1633113725131/image.png"/></figure><p>Here are the options:</p><ul><li><strong>File Path setting:</strong><ul><li><strong>Fixed Value:</strong> this is the default. Selecting <strong>Fixed Value</strong> means that you will set a static file path or expression in the step.</li><li><strong>Runtime Input:</strong> select this option if you want to enter a value at runtime or using <a href="/article/3fqwa8et3d-input-sets">Input Sets and Overlays</a>.</li></ul></li><li><strong>File path field:</strong><ul><li><strong>Fixed Value:</strong> this is the default. Selecting <strong>Fixed Value</strong> means that you will set a static file path in the step.</li><li><strong>Expression:</strong> Selecting <strong>Expression</strong> means that you will use a variable in the step, such as a <a href="/article/2chyf1acil-add-a-stage">stage variable</a>.</li></ul></li></ul><h3 id="skip_dry_run">Option: Skip Dry Run</h3><p>By default, Harness uses the <code>--dry-run</code> flag on the <code>kubectl apply</code> command, which prints the object that would be sent to the cluster without really sending it. If the <strong>Skip Dry Run</strong> option is selected, Harness will not use the <code>--dry-run</code> flag.</p><h3>Option: Skip Steady State Check</h3><p>By default, Harness checks to see if a deployed workload has reached steady state.</p><p>If you select this option, Harness will not check that the workload has reached steady state.</p><h3>Skip K8s Manifest(s) Rendering</h3><p>By default, Harness uses Go templating and a values.yaml for templating manifest files. </p><p>In some cases, you might not want to use Go templating because your manifests use some other formatting.</p><p>Use the <strong>Skip K8s Manifest(s) Rendering</strong> option if you want Harness to skip rendering your manifest files using Go templating.</p><p>For details, go to <a href="/article/00el61pzok-deploy-manifests-separately-using-apply-command">Deploy Manifests Separately using Apply Step</a>.</p><h3 id="apply_step_examples">Apply Step Examples</h3><p>Deploying a resource out of sync with the main resource deployment in a stage can be useful if a specific resource requires some external service processing that is orchestrated around your main rollout, such as database migration.</p><p>One reason why a Job controller object is a good use of the Kubernetes Apply step is that it represents a finite task that runs to completion rather than managing an ongoing desired state. You can run a Job to do perform work outside of the primary object deployment, such as large computation and batch-oriented tasks.</p><p>In another example, let&#39;s say you have two services, serviceA calls serviceB to populate a product page. The primary Deployment rollout deploys serviceB successfully and then the Apply step deploys serviceA next, ensuring serviceA only calls serviceB after serviceB is deployed successfully.</p><p>Another example of the use of the Apply step is service mesh traffic shifting. Your main workload rollout can deploy your services and then an Apply step can apply the resource that modifies the service mesh for the deployed services.</p><h3>Notes</h3><ul><li>The Apply step does not version ConfigMap and Secret objects. ConfigMap and Secret objects are overwritten on each deployment. This is the same as when ConfigMap and Secret objects are marked as unversioned in typical rollouts (<code>harness.io/skip-versioning: true</code>). See <a href="/article/zahb65jgmy-kubernetes-releases-and-versioning">Kubernetes Releases and Versioning</a>.</li></ul><h3>Next Steps</h3><ul><li><a href="/article/u7h63vxg7z-kubernetes-annotations-and-labels">Kubernetes Annotations and Labels</a></li></ul><p></p>