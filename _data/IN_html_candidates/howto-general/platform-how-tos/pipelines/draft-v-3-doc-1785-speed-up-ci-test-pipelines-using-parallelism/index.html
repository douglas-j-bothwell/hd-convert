<div class="note-callout">Currently, this feature is behind a Feature Flag. Contact <a href="mailto:support@harness.io" target="_blank">Harness Support</a> to enable the feature.</div><p><em>Parallelism</em> is one of the <a href="https://docs.harness.io/article/eh4azj73m4">looping strategies</a> available in Harness pipelines.  Using Parallelism, CI users can split their tests into groups that are executed in parallel in order to reduce the tests cycle time. This is one of the <a href="https://docs.harness.io/article/g3m7pjq79y" target="_blank">available methods</a> you can use to speed up your CI builds.</p><h3>Before You Begin</h3><p>This topic assumes that you are familiar with the following:</p><ul><li><a href="/article/3amcd8hn53-ci-pipeline-basics">CI Pipeline Basics</a></li><li><a href="https://docs.harness.io/article/eh4azj73m4" target="_blank">Looping Strategies Overview</a></li><li><a href="https://docs.harness.io/article/q7i0saqgw4">Best Practices for Looping Strategies</a></li></ul><h3>Important Notes </h3><ul><li>The number of concurrent jobs you can run in your account depends on your Harness plan, as indicated below. If exceeded, any additional jobs are queued.<ul><li>Free – 5</li><li>Team – 10</li><li>Enterprise – 100</li></ul></li><li>Please consider any resource constraints in your build infrastructure when using parallelism. See <a href="https://docs.harness.io/article/q7i0saqgw4" target="_blank">Best Practices for Looping Strategies</a> to learn more.</li><li>You can implement a parallelism strategy for an entire Stage or for individual Steps within a Stage. The primary difference between the strategies is how the test groups are run.<br/>A Stage-level parallelism strategy runs the test groups in <em>separate</em> pods or VMs.<br/>A Step-level strategy runs the test groups in separate containers <em>within the same</em> pod or VM.</li><li>If you want to publish your test results, you must ensure that your output files are in <a href="https://junit.org/junit5/" target="_blank">JUnit</a> XML format. How you publish your test results depends on the specific language, test runner, and formatter used in your repo.</li></ul><h3>YAML Example</h3><p>The following snippet shows a YAML definition of a Run Step that uses <a href="https://docs.pytest.org/" target="_blank">pytest</a> to test a set of four test groups in parallel. The following sections describe how to set up a Run Step using this example.</p><pre class="hljs yaml">                          - step:<br/>                                type: Run<br/>                                name: Run Pytests<br/>                                identifier: Run_Pytests<br/># STEP 1: DEFINE THE PARALLELISM VALUE<br/>                              strategy:<br/>                                    parallelism: 4<br/>                                spec:<br/>                                    connectorRef: dbothwelldockerhub<br/>                                    image: python:latest<br/>                                    shell: Sh<br/> # STEP 2: DEFINE ENVIRONMENT ATTRIBUTES<br/>                                    envVariables:<br/>                                        ITERATION_INDEX: &lt;+strategy.iteration&gt;<br/>                                        ITERATIONS_TOTAL: &lt;+strategy.iterations&gt;<br/>                                    command: |-<br/>                                        pip install -r requirements.txt<br/># STEP 3: SPLIT YOUR TESTS INTO GROUPS<br/>#         Your first pipeline run requires `--split-by file_timing`<br/>                                        FILES=`/addon/bin/split_tests --glob &#34;**/test_*.py&#34; --split-by file_timing --split-index ${ITERATION_INDEX} --split-total=${ITERATIONS_TOTAL}`<br/>                                        # FILES=`/addon/bin/split_tests --glob &#34;**/test_*.py&#34; --split-by file_size`<br/>                                        echo $FILES<br/>                                        pytest -v --junitxml=&#34;result_${ITERATION_INDEX}.xml&#34; $FILES<br/># STEP 4: DEFINE YOUR REPORT FILES<br/>                                    reports:<br/>                                        type: JUnit<br/>                                        spec:<br/>                                            paths:<br/>                                                - &#34;**/result_${ITERATION_INDEX}.xml&#34;<br/>                                failureStrategies: []</pre><h3>Step 1: Specify the <code>parallelism</code> value</h3><p>The parallelism value defines how many Steps you want to run in parallel. In general, a higher value means a faster completion time for all tests. The primary restraint is the resource availability in your build infrastructure. The YAML definition looks like this:</p><pre>- step:<br/>      ...<br/>      strategy:<br/>        parallelism: 4</pre><p></p><p>You can also configure parallelism in the Pipeline Studio:</p><ol><li>In the Pipeline Studio, open the Step or Stage where you run your Tests and click the <strong>Advanced</strong> tab.</li><li>Under <strong>Looping Strategies</strong>, select <strong>Parallelism</strong> and define your strategy.<figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/kce8mgionj/1658586760649/parallelism-yaml-no-max-c.png" style="display:block;margin-left:0;margin-right:auto" data-hd-align="left"/></figure></li></ol><p>You can also use a For Loop to define your parallelism strategy. The following definition is functionally equivalent to the previous one:</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/kce8mgionj/1658586791217/for-loop-yaml-no-max-c.png" style="display:block;margin-left:0;margin-right:auto" data-hd-align="left"/></figure><h3>Step 2: Define Environment Attributes</h3><p>You can use the following variables in your Pipelines:</p><ul><li><code>&lt;+strategy.iterations&gt;</code> — The total number of iterations in the current Stage or Step. This is equal to the <code>parallelism</code> value.</li><li><code>&lt;+strategy.iteration&gt;</code> — The index of the current test run. This index is in the range of <code>0</code> to <code>parallelism</code><code>- 1</code>.</li></ul><p> Here&#39;s an example of how you can use these variables in a Build Stage:</p><pre>export HARNESS_POD_INDEX=&lt;+strategy.iteration&gt;<br/>export HARNESS_PODS_TOTAL=&lt;+strategy.iterations&gt;<br/>TESTS=`./split_tests --glob &#34;**/test_*.py&#34;`<br/>pytest -v --junitxml=&#34;result_${HARNESS_POD_INDEX}.xml&#34; $TESTS<br/>echo &#34;Generated file $TESTS. Total iterations = ${HARNESS_PODS_TOTAL}&#34; <br/>cat $TESTS</pre><h3>Step 3: Split Your Tests into groups</h3><p>You use the <code>split_tests</code> CLI command to define the set of tests you want to run. In the <strong>Command</strong> field of the Step where you run your tests, you can include code like this:</p><pre># generates a new set of grouped test files <br/># and outputs the file list to a string:<br/><br/>TESTS=`/addon/bin/split_tests --glob &#34;**/test_*.py --split-by file_size&#34;`<br/><br/># echo $TESTS<br/># example output: test_api_2.py test_api_4.py test_api_6.py</pre><p></p><p>The <code>split_tests</code> command creates a new set of test files that reflect your splitting criteria. This command takes the following as inputs:</p><ul><li>The <code>parallelism</code> value you specified previously.</li><li>The set of all the tests you want to run (<code>--glob</code> argument).</li><li>The algorithm used to split the tests into groups (<code>--split-by</code> argument). In this example, we use the default <code>file_size</code> setting, which splits the tests based on file size.<div class="note-callout">You can also choose to split groups based on timing criteria, but you need to run the Pipeline at least once to collect timing data for your tests. These splitting options are discussed below.</div></li></ul><h3>Step 4: Define Your Report Files</h3><p>The <code>report</code> section defines how the Pipeline publishes your test results. Here&#39;s an example:</p><pre class="hljs yaml">reports: <br/>   type: JUnit <br/>      spec: <br/>         paths: - &#34;**/result_&lt;+strategy.iteration&gt;.xml&#34;</pre><p></p><p>If you want to publish your test results, you need to do the following:</p><ul><li>Set up your test runner and formatter to publish your test reports in <a href="https://junit.org/junit5/" target="_blank">JUnit</a> XML format and to include filenames in the XML output.<br/>Refer to your test-runner documentation to ensure that your reports are published in the correct format.</li><li>If you are implementing parallelism in a Step rather than a Stage, you need to make sure that each test-group step generates a report with a unique filename.<br/>You can do this using the <code>&lt;+strategy.iteration&gt;</code>variable, which is the index of the current test run. This index is in the range of <code>0</code> to <code>parallelism</code><code>- 1</code>. See also <a href="https://docs.harness.io/article/qojpse1baq#using_parallelism_variables_in_your_pipeline" target="_blank">Using Parallelism Variables in your Pipeline</a> below.</li></ul><p>You can configure your test reporting options in the pipeline YAML, as shown above, or in the Pipeline Studio. Go to the Run or Run Tests Step and configure the <strong>Report Paths</strong> field under Optional Configuration.</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/kce8mgionj/1658587230180/report-paths-field.png" style="display:block;margin-left:0;margin-right:auto" data-hd-align="left"/></figure><p></p><h3>Step 4: Run the Pipeline</h3><p>Run your Pipeline to make sure all your Steps complete successfully. You can see the parallel copies of your Step running in the Build UI.</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/kce8mgionj/1658588151618/test-run-1-in-progress.png" style="max-height:50;max-width:50%" data-hd-height="50" data-hd-width="50%"/></figure><p>When the build finishes, go to the Tests tab and view your results. You can view results for each parallel step using the pull-down.</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/kce8mgionj/1658588195696/test-results-1-step-picker.png" style="display:block;margin-left:0;margin-right:auto" data-hd-align="left"/></figure><h3>Step 6: Split your Tests by Time</h3><p>Harness supports splitting your tests based on timing criteria. These options require that you run the Pipeline at least once to collect timing data for your individual test. Now that you have run your Pipeline, you can specify other splitting options besides the default <code>file_size</code> setting.</p><p>You can update the split_tests command as follows:</p><pre class="hljs yaml"># First run:<br/># TESTS=`./split_tests --glob &#34;**/test_*.py --split-by file_size&#34;`<br/><br/># Now that you have collected timing info, you can use a time-based splitting option:<br/>TESTS=`./split_tests --glob &#34;**/test_*.py --split-by class_timing&#34;`</pre><div class="note-callout">Splitting your tests by time is more effective than splitting them by file size. It is good practice to specify a time-based splitting strategy after you run your Pipeline for the first time.</div><p>Harness supports the following time-based splitting options:</p><ul><li><code>--split-by file_timing</code> — Split files into groups based on the test times of individual files.</li><li><code>--split-by class_timing</code> — Split test classes into groups based on times from the previous run.</li><li><code>--split-by testcase_timing</code> — Split test cases into groups based on times from the previous run.</li><li><code>--split-by suite_timing</code> — Split test suites into groups based on times from the previous run.</li></ul><p>Whatever the time-based splitting option you choose, the Pipeline splits your tests to ensure that all parallel Steps finish at approximately the same time.</p><p></p><h3>See Also</h3><ul><li><a href="https://harness.helpdocs.io/article/g3m7pjq79y" target="_blank">Optimizing CI Build Times</a></li><li><a href="https://harness.helpdocs.io/article/eh4azj73m4" target="_blank">Looping Strategies Overview: Matrix, For Loop, and Parallelism</a></li><li><a href="https://docs.harness.io/article/q7i0saqgw4">Best Practices for Looping Strategies</a></li><li><a href="https://docs.harness.io/article/kay7z1bi01" target="_blank">Run a Stage or Step Multiple Times using a Matrix and Parameters</a></li></ul><p></p>