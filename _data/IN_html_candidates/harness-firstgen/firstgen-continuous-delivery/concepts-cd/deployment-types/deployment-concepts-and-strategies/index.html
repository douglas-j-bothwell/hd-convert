<p></p><div class="tip-callout">This content is for Harness <a href="/article/1fjmm4by22">FirstGen</a>. Switch to <a href="/article/0zsf97lo3c">NextGen</a>.</div><p>You have likely heard terms like <em>blue/green</em> and <em>canary</em> when it comes to deploying code and applications into production. These are common deployment strategies, available in Harness as Workflow types, along with many others.</p><figure><a href="https://files.helpdocs.io/i5nl071jo5/articles/0zsf97lo3c/1578597448765/image.png"><img src="https://files.helpdocs.io/i5nl071jo5/articles/0zsf97lo3c/1578597448765/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></a></figure><p>This topic will explain these strategies to give you an idea of how to approach deployments in Harness, and to help you decide what strategy is best for you.</p><p>In this topic:</p><ul><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#build_deployment">Build Deployment</a></li><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#basic_deployment">Basic Deployment</a></li><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#multi_service_deployment">Multi-Service Deployment</a></li><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#rolling_deployment">Rolling Deployment</a></li><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#blue_green_deployment">Blue/Green Deployment</a></li><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#canary_deployment">Canary Deployment</a></li><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#a_b_testing">A/B Testing</a></li><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#which_deployment_strategy_should_i_use">Which Deployment Strategy Should I Use?</a></li><li> <a href="/article/325x7awntc-deployment-concepts-and-strategies#next_steps">Next Steps</a></li></ul><h3 id="build_deployment">Build Deployment</h3><p>A Build Deployment runs a build process, such as a Jenkins job that creates a WAR file and deposits it in a repo, or builds an AMI in AWS EC2.</p><h4 id="when_to_use_build_deployments">When to use Build Deployments</h4><p>Typically, you use Build deployments as part of an Artifact Build and Deploy pipeline.</p><p>An Artifact Build and Deploy pipeline runs a build process, deposits the built artifact (or metadata) in the Artifact Source or Harness, and deploys the build to a deployment environment. It is a simple, but useful deployment commonly used for traditional file-based and AMI deployments.</p><p>See  <a href="/article/181zspq0b6-build-and-deploy-pipelines-overview">Build and Deploy Pipelines Overview</a>.</p><h4>Build Workflow for Push Events</h4><p>Build Workflows can also be used to build an artifact because the source has been updated.</p><p>For example, you might use a Trigger to execute the Workflow on a Webhook event, such as a Git push event. In this case, the artifact needs to be built before the Workflow can pick it up.</p><p>You simply add a Build Workflow at the beginning of the Pipeline to build the artifact so you always have the latest build.</p><p>See <a href="/article/xerirloz9a-add-a-trigger-2">Triggers</a> for information on Webhook triggers.</p><h3 id="basic_deployment">Basic Deployment</h3><p>With Basic Deployment, all nodes within a single environment are updated at the same time with a single new service/artifact version.</p><h4 id="when_to_use_basic_deployments">When to use Basic Deployments</h4><ul><li>Your app/service is not business, mission, or revenue critical</li><li>You’re deploying off-hours and no one is using the app/service</li><li>Your experimenting with deployments and it&#39;s okay if the app/service fails</li></ul><h5 id="pros">Pros</h5><ul><li>Simple and fast.</li><li>Useful for learning Harness.</li></ul><h5 id="cons">Cons</h5><ul><li>Risk, outages, slower rollback.</li></ul><p>Not too long ago, Basic deployment was how developers rolled out applications. Typically, someone in Ops updates the servers at midnight and then you hope all goes well.</p><figure><a href="https://files.helpdocs.io/i5nl071jo5/articles/0zsf97lo3c/1578597179853/image.png"><img src="https://files.helpdocs.io/i5nl071jo5/articles/0zsf97lo3c/1578597179853/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></a></figure><p>Basic deployments are supported in Harness for a number of platforms as a way for you to experiment with deployments. They are not intended for production deployments because they are not as safe as Canary or Blue/Green deployments.</p><h3 id="multi_service_deployment">Multi-Service Deployment</h3><p>With Multi-Service Deployment, all nodes within a single environment are updated at the same time with <em>multiple</em> new services/artifacts.</p><h4 id="when_to_use_multi_service_deployments">When to use Multi-Service Deployments</h4><ul><li>When your app has service/version dependencies.</li><li>You’re deploying off-hours and no one is using the app/service.</li></ul><h5 id="pros_2">Pros</h5><ul><li>Simple, fast, and with less risk than Basic deployment.</li></ul><h5 id="cons_2">Cons</h5><ul><li>Risk, difficult to test/verify all service dependencies, outages, slow rollback.</li></ul><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840114744/multi-2.png"><img src="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840114744/multi-2.png"/></a></figure><h3 id="rolling_deployment">Rolling Deployment</h3><p>With a Rolling Deployment, all nodes within a single environment are incrementally updated one-by-one or in N batches (as defined by a window size) with a new service/artifact version.</p><h4 id="when_to_use_rolling_deployments">When to use Rolling Deployments</h4><ul><li>When you need to support both new and old deployments.</li><li>Load balancing scenarios that require reduced downtime.</li></ul><p>One use of Rolling deployments is as the stage following a Canary deployment in a deployment pipeline. For example, in the first stage you can perform a Canary deployment to a QA environment and verify each group of nodes and, once successful, you perform a Rolling to production.</p><h5 id="pros_3">Pros</h5><ul><li>Simple, relatively simple to rollback, less risk than Basic deployment.</li><li>Gradual app rollout with increasing traffic.</li></ul><h5 id="cons_3">Cons</h5><ul><li>Verification gates between nodes difficult and slow.</li><li>App/DB needs to support both new and old artifacts. Manual checks/verification at each increment could take a long time.</li><li>Lost transactions and logged-off users are also something to take into consideration.</li></ul><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840114905/rolling-2.png"><img src="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840114905/rolling-2.png"/></a></figure><p>See  <a href="/article/5gouaz9w5r-kubernetes-rolling-update-workflows">Kubernetes Rolling Update Workflows</a>.</p><h3 id="blue_green_deployment">Blue/Green Deployment</h3><p>With Blue/Green Deployment, two identical environments called <strong>blue</strong> (staging) and <strong>green</strong> (production) run simultaneously with different versions or service/artifact.</p><p>QA and UAT are typically done on the blue environment. When satisfied, traffic is flipped (via a load balancer) from the green environment (current version) to the blue environment (new version).</p><p>You can then decommission the old environment once deployment is successful.</p><div class="note-callout">Some vendors<strong> </strong>calls this a red/black deployment.</div><h4 id="when_to_use_blue_green_deployments">When to use Blue/Green Deployments</h4><ul><li>When you want to perform verification in a full production environment.</li><li>When you want zero downtime.</li></ul><h5 id="pros_4">Pros</h5><ul><li>Simple, fast, well understood, and easy to implement: switch is almost instantaneous.</li><li>Less risk relative to other deployment strategies.</li><li>Rapid rollback (flip traffic back to old environment)</li></ul><h5 id="cons_4">Cons</h5><ul><li>Replicating a production environment can be complex and expensive (i.e. microservice downstream dependencies).</li><li>QA/UAT test coverage may not identify all anomalies &amp; regressions in blue environment.</li><li>An outage or SPOF could have wide-scale business impact before rollback kicks in.</li><li>Current transactions and sessions will be lost due to the physical switch from one machine serving the traffic to another one.</li><li>Database compatibility (schema changes, backward compatibility).</li></ul><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840115023/blue-green-2.png"><img src="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840115023/blue-green-2.png"/></a></figure><p>See:</p><ul><li><a href="/article/7qtpb12dv1-ecs-blue-green-workflows">ECS Blue/Green Workflows</a></li><li><a href="/article/vw71c7rxhp-ami-blue-green">AMI Blue/Green Deployment</a></li><li><a href="/article/zim6pw6hd5-blue-green-workflows">Kubernetes Blue/Green Workflows</a></li><li><a href="/article/6m7w43yw4u-pcf-tutorial-overview">Pivotal Cloud Foundry Deployments</a></li></ul><h3 id="canary_deployment">Canary Deployment</h3><p>With Canary Deployment, all nodes in a single environment are incrementally updated in small phases, with each phase requiring a verification/gate to proceed to the next phase.</p><h4 id="when_to_use_canary_deployments">When to use Canary Deployments</h4><p>When you want to verify whether the new version of the application is working correctly in your production environment.</p><p>This is currently the most common way to deploy apps/services into production.</p><p><strong>Pros:</strong></p><ul><li>Deploy in small phases (e.g. 2%, 10%, 25%, 50,%, 75%, 100%).</li><li>Lowest risk relative to all other deployment strategies (reduce business exposure).</li><li>Test in production with real users &amp; use cases.</li><li>Run &amp; compare two service versions side-by-side.</li><li>Cheaper than blue/green, because there is no need to have two production environments.</li><li>Fast and safe rollback.</li></ul><p><strong>Cons:</strong></p><ul><li>Scripting canary deployments can be complex (Harness automates this process).</li><li>Manual verification can take time (Harness automates this process with Continuous Verification).</li><li>Required monitoring and instrumentation for testing in production (APM, Log, Infra, End User, etc).</li><li>Database compatibility (schema changes, backward compatibility).</li></ul><p>This is a standard Canary deployment:</p><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840115126/canary-2.png"><img src="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840115126/canary-2.png"/></a></figure><p>For Kubernetes, Harness does this a little different.</p><p>In Phase 1 we do a canary to the same group but we leave the production version alone. We just use other instances. Then we delete our canary version in Phase 1.</p><p>In Phase 2 we do a rolling deployment with the production version and scale down the older version.</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1616629921936/image.png"/></figure><p>For examples, see:</p><ul><li><a href="/article/agv5t7d156-ami-canary">AMI Canary Deployment</a></li><li><a href="/article/2xp0oyubjj-create-a-kubernetes-canary-deployment">Create a Kubernetes Canary Deployment</a></li></ul><h3 id="a_b_testing">A/B Testing</h3><p>Different versions of the same service/artifact run simultaneously as “experiments” in the same environment (typically production) for a period of time. Experiments are either controlled by the deployment of distinct artifacts or through the use of feature flags/toggling and/or AB testing tools (e.g. Optimizely).</p><p>User traffic is commonly routed to each different version/experiment based on specific rules or user demographics (e.g. location, interests, etc). Measurements and comparisons are then performed across experiments to see which returned the best result.</p><p>After experiments are concluded, the environment is typically updated with the optimal service version/experiment.</p><p>The biggest difference between AB testing and the other strategies is that AB testing deploys many versions of the same service/artifact to an environment with no immediate goal of updating all nodes with a specific version. It’s about testing multiple ideas vs. deploying one specific tested idea.</p><h4 id="pros_5">Pros</h4><p>Fast, easy and cheap way to test new features in production. Lots of tools exist to enable this.</p><h4 id="cons_5">Cons</h4><ul><li>Experiments can sometimes break app/service/user experience.</li><li>Scripting AB tests can be complex.</li><li>Database compatibility (schema changes, backward compatibility)</li></ul><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840115304/ab-2.png"><img src="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1620840115304/ab-2.png"/></a></figure><h3 id="which_deployment_strategy_should_i_use">Which Deployment Strategy Should I Use?</h3><p>It depends entirely on the type of application/service and environment. Most Harness customers are currently using blue/green or canary deployments for mission-critical applications.</p><p>In many cases, customers are migrating from blue/green to canary so they can test in production with minimal business impact.</p><p>You can also combine many of the above deployment strategies into a single strategy. For example, at Harness, we have customers doing multi-service canary deployments.</p><h3 id="next_steps">Next Steps</h3><ul><li> <a href="/article/4o7oqwih6h-harness-key-concepts">Harness Key Concepts</a></li></ul><p></p>