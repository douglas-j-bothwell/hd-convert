type: article
article_id: qpv2jfdjgm
user_id: mfr0nxh4be
category_id: n03qfofd5w
author:
  name: Michael Cretzman
  profile_image: https://www.gravatar.com/avatar/2e8616837f4ee92be5d19ffe9b9ccba9?d=mm&s=150
title: Run Kubernetes Jobs
slug: run-kubernetes-jobs
description: Define and execute Kubernetes Jobs in Harness.
short_version: Define and execute Kubernetes Jobs in Harness.
tags: []
show_toc: true
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: Article updated
  source: API
  triggered_at: 2021-09-30T20:08:47.245523Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Run Kubernetes Jobs
  description: Define and execute Kubernetes Jobs in Harness.
  short_version: Define and execute Kubernetes Jobs in Harness.
  body: '<p>Kubernetes <a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/"
    target="_blank">Jobs</a> create one or more pods to carry out commands. For example,
    a calculation or a backup operation.</p><p>In Harness Kubernetes deployments,
    you define Jobs in the Harness Service <strong>Manifests</strong>. Next you add
    the <strong>Apply</strong> step to your Harness Workflow to execute the Job.</p><p>In
    this topic, we will show you how to execute a Job in a Harness Kubernetes deployment
    as part of the main deployment.</p><div class="note-callout">Typically, Jobs are
    not part of the main deployment. You can exclude them from the main deployment
    and simply call them at any point in the Workflow using the Apply step. For steps
    on ignoring the Job as part of the main deployment and executing it separately,
    see <a href="/article/4vjgmjcj6z-deploy-manifests-separately-using-apply-step">Deploy
    Manifests Separately using Apply Step</a>.</div><p>In this topic:</p><ul><li><a
    href="#before_you_begin">Before You Begin</a></li><li><a href="#visual_summary">Visual
    Summary</a></li><li><a href="#review_apply_step">Review: Apply Step</a></li><li><a
    href="#step_1_add_job_manifest">Step 1: Add Job Manifest</a></li><li><a href="#step_2_define_target_cluster">Step
    2: Define Target Cluster</a></li><li><a href="#step_3_add_the_job_to_the_workflow">Step
    3: Add the Job to the Workflow</a></li><li><a href="#option_delegate_selector">Option:
    Delegate Selector</a></li><li><a href="#option_skip_steady_state_check">Option:
    Skip Steady State Check</a></li><li><a href="#option_add_test_and_clean_up_steps">Option:
    Add Test and Clean Up Steps</a></li><li><a href="#step_4_deploy_the_job">Step
    4: Deploy the Job</a></li><li><a href="#option_showing_job_output">Option: Showing
    Job Output</a></li><li><a href="#summary">Summary</a></li><li><a href="#one_more_thing_to_try">One
    More Thing to Try</a></li></ul><h3>Before You Begin</h3><ul><li><strong>​Kubernetes
    Jobs</strong> — We assume you are familiar with <a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/"
    target="_blank">Kubernetes Jobs</a>.</li><li><strong>Apply step</strong> — The
    Harness Workflow Apply step allows you to deploy any resource you have set up
    in the Service <strong>Manifests</strong> section at any point in your Workflow.
    See  <a href="https://docs.harness.io/article/4vjgmjcj6z-deploy-manifests-separately-using-apply-step">Deploy
    Manifests Separately using Apply Step</a>.</li><li><strong>Ignoring Manifests</strong>
    — You can annotate a manifest to have Harness ignore it when performing its main
    deployment operations. Then you can use the Apply step to execute the manifest
    wherever you want to run it in the Workflow. See <a href="/article/vv25jkq4d7-ignore-a-manifest-file-during-deployment">Ignore
    a Manifest File During Deployment</a>.</li><li><strong>Delete Jobs before rerunning
    deployments</strong> — Once you&#39;ve deployed the Job, you must delete it before
    deploying a Job of the same name to the same namespace.</li></ul><h3>Visual Summary</h3><p>In
    this topic, we will walk through a simple Job deployment. Here is the completed
    deployment in Harness:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585075911275/image.png"/></figure><h3>Review:
    Apply Step</h3><p>Workflows include an <strong>Apply</strong> step that allows
    you to deploy <em>any resource</em> you have set up in the Service <strong>Manifests</strong> section.</p><p>For
    details on what you can deploy in different Harness Workflow types, see <a href="/article/6ujb3c70fh-what-can-i-deploy-in-kubernetes">What
    Can I Deploy in Kubernetes?</a>.</p><p>The Apply step can deploy <em>all workload
    types</em>, including Jobs in any Workflow type.</p><p>You can add an Apply step
    anywhere in your Harness Workflow. This makes the Apply step useful for running
    Kubernetes Jobs.</p><p>Here are some Job examples:</p><ul><li>Run independent
    but related work items in parallel: sending emails, rendering frames, transcoding
    files, or scanning database keys.</li><li>Create a new pod if the first pod fails
    or is deleted due to a node hardware failure or node reboot. </li><li>Create a
    Job that cleans up the configuration of an environment, to create a fresh environment
    for deployment.</li><li>Use a Job to spin down the replica count of a service,
    to save on cost.</li></ul><div class="note-callout">Any workload deployed with
    the <strong>Apply</strong> step is not rolled back by Harness.</div><h3>Step 1:
    Add Job Manifest</h3><p>For this topic, we will create a Service named <strong>Countdown</strong>
    of the Kubernetes Deployment Type.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585081455300/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>The
    Job manifest is added to the Harness Service <strong>Manifests</strong> section.</p><p>Here
    is a Job that will countdown from 15 to 1 and print out the countdown when complete:</p><pre>apiVersion:
    batch/v1<br/>kind: Job<br/>metadata:<br/>  name: {{.Values.name}}<br/>spec:<br/>  template:<br/>    metadata:<br/>      name:
    {{.Values.name}}<br/>      labels:<br/>        app: {{.Values.name}}<br/>    spec:<br/>      containers:<br/>      -
    name: counter<br/>        image: {{.Values.image}}<br/>        command:<br/>         -
    &#34;bin/bash&#34;<br/>         - &#34;-c&#34;<br/>         - &#34;for i in $(seq
    1 15); do echo $((16-i)); sleep 1s; done&#34;<br/>      restartPolicy: Never</pre><p>In
    your Harness Service, in <strong>Manifests</strong>, you simply add the Job in
    a manifest file. Let&#39;s walk through adding the manifest and the values.yaml
    file.</p><p>First, we add a <a href="https://hub.docker.com/_/centos" target="_blank">CentOS
    Docker Image</a> as the <a href="/article/gxv9gj6khz-add-a-docker-image-service">Docker
    Registry Artifact Source</a> for the Service.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585076654499/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>Next,
    we create the <strong>countdown.yaml</strong> file in a <strong>templates</strong>
    folder. It contains the exact same countdown Job example listed above:</p><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585155834686/image.png"/></figure><p>Next,
    edit <strong>values.yaml</strong> to contain the name and image labels only:</p><pre>name:
    countdown<br/>image: ${artifact.metadata.image}</pre><p>Now that the Job is added
    to the Service, we can select the target cluster where the Job will be deployed.</p><h3>Step
    2: Define Target Cluster</h3><p>Jobs do not require any changes to the way you
    specify the target cluster in Harness.</p><p>For steps on setting up the target
    cluster, see <a href="/article/u3rp89v80h-define-your-kubernetes-target-infrastructure">Define
    Your Kubernetes Target Infrastructure</a>.</p><h3>Step 3: Add the Job to the Workflow</h3><p>For
    this topic, we will create a Harness Rolling Workflow for our Service, named <strong>Countdown</strong>.</p><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585081388489/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><ol><li>In
    the Workflow <strong>Deploy</strong> section, delete the <strong>Rollout Deployment</strong>
    step. We don&#39;t need the Rollout Deployment step because we will simply deploy
    the Job using the <strong>Apply</strong> step.</li><li>In the Workflow <strong>Deploy</strong>
    section, click <strong>Add Step</strong>, and then select the <strong>Apply</strong>
    step.</li><li>Set up the Apply step to use the Job manifest in the Service <strong>Manifests</strong>:
    <code>templates/countdown.yaml</code>.</li></ol><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585081662549/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>That&#39;s
    all you have to do to add the Job to your Workflow. Next, we&#39;ll add some test
    and clean up steps.</p><h3>Option: Delegate Selector</h3><p>The Apply step has
    the Delegate Selector option.</p><p>If your Workflow Infrastructure Definition&#39;s
    Cloud Provider uses a Delegate Selector (supported in Kubernetes Cluster and AWS
    Cloud Providers), then the Workflow uses the selected Delegate for all of its
    steps.</p><p>In these cases, you shouldn&#39;t add a Delegate Selector to any
    step in the Workflow. The Workflow is already using a Selector via its Infrastructure
    Definition&#39;s Cloud Provider.</p><p>If your Workflow Infrastructure Definition&#39;s
    Cloud Provider isn&#39;t using a Delegate Selector, and you want this Workflow
    step to use a specific Delegate, do the following:</p><p>In <strong>Delegate Selector</strong>,
    select the Selector for the Delegate(s) you want to use. You add Selectors to
    Delegates to make sure that they&#39;re used to execute the command. For more
    information, see <a href="/article/c3fvixpgsl-select-delegates-for-specific-tasks-with-selectors">Select
    Delegates with Selectors</a>.</p><p>Harness will use Delegates matching the Selectors
    you add.</p><p>If you use one Selector, Harness will use any Delegate that has
    that Selector.</p><p>If you select two Selectors, a Delegate must have both Selectors
    to be selected. That Delegate might also have other Selectors, but it must have
    the two you selected.</p><div class="note-callout">You can use expressions for
    Harness built-in variables or Account Default variables in <strong>Delegate Selectors</strong>.
    When the variable expression is resolved at deployment runtime, it must match
    an existing Delegate Selector.<br/><br/>For example, if you have a Delegate Selector <strong>prod</strong> and
    the Workflow is using an Environment also named <strong>prod</strong>, the Delegate
    Selector can be <code>${env.name}</code>. This is very useful when you match Delegate
    Selectors to Application component names such as Environments, Services, etc.
    It&#39;s also a way to template the Delegate Selector setting.</div><p></p><h3>Option:
    Skip Steady State Check</h3><p>If you select this option, Harness will not check
    that the workload (Job) has reached steady state.</p><h3>Option: Add Test and
    Clean Up Steps</h3><ol><li>In <strong>Workflow Variables</strong>, add a new variable
    named <strong>JobName</strong> and give it the value <code>countdown</code>. We
    will use this variable in a Shell Script step to check if the Job is complete.<figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585082264183/image.png"/></figure></li><li>In
    the <strong>Verify</strong> section of the Workflow, click <strong>Add Step</strong>,
    and then select the <strong>Shell Script</strong> step.</li><li>In the Shell Script
    step, in <strong>Script</strong>, add the following script to check if the Job
    completed:</li></ol><pre>kubectl wait --for=condition=complete --timeout=30s jobs/${workflow.variables.JobName}
    -n ${infra.kubernetes.namespace}</pre><p>You can see the script uses the Workflow
    variable expression <code>${workflow.variables.JobName}</code> to get the name
    of the Job, <strong>countdown</strong>.</p><p>Next, we&#39;ll add a Shell Script
    step to output the log for the Job. When we deploy, the log will display the countdown
    from 15 to 1 performed by the Job.</p><ol><li style="counter-increment:li 3" start="4">In
    the <strong>Wrap Up</strong> section of the Workflow, add another Shell Script
    step. In <strong>Script</strong>, enter the following script:</li></ol><pre>kubectl
    logs -n ${infra.kubernetes.namespace} $(kubectl get pods -n ${infra.kubernetes.namespace}
    -l job-name=${workflow.variables.JobName} -o jsonpath=&#39;{.items[*].metadata.name}&#39;)</pre><p>Finally,
    let&#39;s add a <strong>Delete</strong> step to remove the Job.</p><ol><li style="counter-increment:li
    4" start="5">In the <strong>Wrap Up</strong> section of the Workflow, after the
    Shell Script step, click <strong>Add Step</strong>. Select the <strong>Delete</strong>
    step.</li><li>In <strong>Resources</strong>, enter the type and name of the resource,
    <code>Job/countdown</code>.</li></ol><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585088682314/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>See
    <a href="/article/78oginrhsh-delete-kubernetes-resources">Delete Kubernetes Resources</a>
    for more information on how to reference resources.</p><p>Now that our Job deployment
    is set up, we can run it.</p><h3>Step 4: Deploy the Job</h3><ol><li>In the Workflow,
    click <strong>Deploy</strong>.</li><li>In <strong>Start New Deployment</strong>,
    we enter <code>countdown</code> for the <strong>JobName</strong> Workflow variable,
    select a <strong>Build/Version</strong> for our CentOS artifact, and click <strong>Submit</strong>.</li></ol><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585090115181/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>Let&#39;s
    look at the results of each step.</p><p>In the <strong>Apply</strong> step, in
    <strong>Wrap Up</strong>, you can see that the Job is run:</p><pre>Wrapping up..<br/><br/><br/>kubectl
    --kubeconfig=config describe --filename=manifests.yaml<br/><br/>Name:           countdown<br/>Namespace:      default<br/>Selector:       controller-uid=aff025af-6ebe-11ea-b052-4201ac10c80b<br/>Labels:         app=countdown<br/>                controller-uid=aff025af-6ebe-11ea-b052-4201ac10c80b<br/>                job-name=countdown<br/>Annotations:    kubectl.kubernetes.io/last-applied-configuration:<br/>                  {&#34;apiVersion&#34;:&#34;batch/v1&#34;,&#34;kind&#34;:&#34;Job&#34;,&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;kubernetes.io/change-cause&#34;:&#34;kubectl
    apply --kubeconfig=config --filenam...<br/>                kubernetes.io/change-cause:
    kubectl apply --kubeconfig=config --filename=manifests.yaml --record=true<br/>Parallelism:    1<br/>Completions:    1<br/>Start
    Time:     Wed, 25 Mar 2020 17:33:06 +0000<br/>Completed At:   Wed, 25 Mar 2020
    17:33:22 +0000<br/>Duration:       16s<br/>Pods Statuses:  0 Running / 1 Succeeded
    / 0 Failed<br/>Pod Template:<br/>  Labels:  app=countdown<br/>           controller-uid=aff025af-6ebe-11ea-b052-4201ac10c80b<br/>           job-name=countdown<br/>  Containers:<br/>   counter:<br/>    Image:      registry.hub.docker.com/library/centos:6.10<br/>    Port:       &lt;none&gt;<br/>    Host
    Port:  &lt;none&gt;<br/>    Command:<br/>      bin/bash<br/>      -c<br/>      for
    i in $(seq 1 15); do echo $((16-i)); sleep 1s; done<br/>    Environment:  &lt;none&gt;<br/>    Mounts:       &lt;none&gt;<br/>  Volumes:        &lt;none&gt;<br/>Events:<br/>  Type    Reason            Age   From            Message<br/>  ----    ------            ----  ----            -------<br/>  Normal  SuccessfulCreate  22s   job-controller  Created
    pod: countdown-wzph5<br/><br/>Done.</pre><p>In the Shell Script step in <strong>Verify</strong>,
    we can see that our Job completed:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585090295460/image.png"/></figure><p>In
    the Shell Script step in <strong>Wrap Up</strong>, we can see the log for the
    Job pod:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585090402698/image.png"/></figure><p>Finally,
    in the <strong>Delete</strong> step, you can see the countdown Job deleted.</p><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585090444354/image.png"/></figure><h3>Option:
    Showing Job Output</h3><p>To view Job output after the Apply step, you can use
    a simple script in a <a href="/article/1fjrjbau7x-capture-shell-script-step-output">Shell
    Script</a> step:</p><pre>echo<br/><br/>pods=$(kubectl get pods -n ${infra.kubernetes.namespace}
    --selector=job-name=my-job --output=jsonpath=&#39;{.items[*].metadata.name}&#39;)<br/><br/>kubectl
    logs -n ${infra.kubernetes.namespace} $pods<br/><br/>echo</pre><p></p><p>If you
    need to show the logs <em>during</em> job execution rather than after the Apply
    step, then modify the script and run the step in parallel with Apply.</p><p>Alternatively,
    if you have your cluster logs going to a log service you can generate a URL to
    that system that shows the job logs in parallel as well.</p><h3>Summary</h3><p>Using
    the Apply step, you are able to configure, manage, and deploy a Kubernetes Job.</p><h3>One
    More Thing to Try</h3><p>As we demonstrated, you can get the status of the Job
    using a simple script. In addition, you can output that status to a Jira, ServiceNow,
    or Email step using the Shell Script step <strong>Publish Variable Name</strong>.</p><p>For
    example, let&#39;s change the Shell Script that checks the success of the Job.
    We will add the output to a variable and then publish that variable:</p><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585158018127/image.png"/></figure><p>Now
    you can obtain the output via the variable expression <code>${context.checkjob.jobstatus}</code>.
    Here&#39;s an Email step using the published variable:</p><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/qpv2jfdjgm/1585157871040/image.png"/></figure><p>For
    information on these collaboration tools, see:</p><ul><li> <a href="/article/077hwokrpr-jira-integration">Jira
    Integration</a></li><li> <a href="/article/7vsqnt0gch-service-now-integration">ServiceNow
    Integration</a></li><li> <a href="/article/cv98scx8pj-collaboration-providers">Add
    Collaboration Providers</a></li></ul><p></p>'
  slug: run-kubernetes-jobs
  tags: []
  is_live: true
