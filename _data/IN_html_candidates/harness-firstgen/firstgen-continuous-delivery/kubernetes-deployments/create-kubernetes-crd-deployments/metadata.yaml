type: article
article_id: pmmfqqo1uh
user_id: mfr0nxh4be
category_id: n03qfofd5w
author:
  name: Michael Cretzman
  profile_image: https://www.gravatar.com/avatar/2e8616837f4ee92be5d19ffe9b9ccba9?d=mm&s=150
title: Deploy Kubernetes Custom Resources using CRDs
slug: create-kubernetes-crd-deployments
description: Harness supports all Kubernetes default resources, such as Pods, Deployments,
  StatefulSets, DaemonSets, etc. For these resources, Harness supports steady state
  checking, versioning, displays instance…
short_version: Harness supports all Kubernetes default resources, such as Pods, Deployments,
  StatefulSets, DaemonSets, etc. For these resources, Harness supports steady state
  checking, versioning, displays instance…
tags: []
show_toc: true
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: Article updated
  source: API
  triggered_at: 2021-11-09T00:37:16.214564Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Deploy Kubernetes Custom Resources using CRDs
  description: ""
  short_version: ""
  body: '<p>Harness supports all Kubernetes default resources, such as Pods, Deployments,
    StatefulSets, DaemonSets, etc. For these resources, Harness supports steady state
    checking, versioning, displays instances on Harness dashboards, performs rollback,
    and other enterprise features.</p><p>In addition, Harness provides many of the
    same features for Kubernetes <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">custom
    resource</a> deployments using Custom Resource Definitions (CRDs). CRDs are resources
    you create that extend the Kubernetes API to support your application.</p><div
    class="note-callout">Harness supports CRDs for both Kubernetes and OpenShift.
    There is no difference in their custom resource implementation.</div><p>In this
    topic:</p><ul><li> <a href="#before_you_begin">Before You Begin</a></li><li> <a
    href="#limitations">Limitations</a></li><li> <a href="#review_required_custom_resource_annotations_and_labels">Review:
    Required Custom Resource Annotations and Labels</a></li><li> <a href="#step_1_prepare_target_cluster">Step
    1: Prepare Target Cluster</a></li><li> <a href="#step_2_define_custom_resource_in_harness">Step
    2: Define Custom Resource in Harness</a></li><li> <a href="#step_3_define_target_cluster">Step
    3: Define Target Cluster</a></li><li> <a href="#step_4_create_workflow_for_custom_resource_deployment">Step
    4: Create Workflow for Custom Resource Deployment</a></li><li> <a href="#step_5_deploy_custom_resource">Step
    5: Deploy Custom Resource</a></li><li> <a href="#see_also">See Also</a></li><li>
    <a href="#configure_as_code">Configure As Code</a></li></ul><h3>Before You Begin</h3><ul><li>
    <a href="/article/7in9z2boh6-kubernetes-quickstart">Kubernetes Quickstart</a></li><li>
    <a href="/article/dl0l34ge8l-create-a-kubernetes-rolling-deployment">Create a
    Kubernetes Rolling Deployment</a></li><li> <a href="/article/ttn8acijrz-versioning-and-annotations">Kubernetes
    Versioning and Annotations</a></li></ul><h3>Limitations</h3><h4>Rollbacks</h4><p>Harness
    only performs rollback for the default Kubernetes objects. For failures with CRDs,
    Harness redeploys the previous successful version.</p><p>Harness redeploys using
    the last successful release that matches the <code>release-name</code> label value
    (<code>harness.io/release-name: &lt;release_name&gt;</code>), described below.</p><h4>Rolling
    Deployment Only</h4><p>Blue/Green and Canary deployments are not supported at
    this time. See <a href="/article/dl0l34ge8l-create-a-kubernetes-rolling-deployment">Create
    a Kubernetes Rolling Deployment</a>.</p><h4>Versioning</h4><p>ConfigMap and Secrets
    are not versioned.</p><h3>Review: Harness Custom Resource Requirements</h3><p>To
    use a custom resource in Harness, you need to add the following annotations to
    its manifest:</p><h4>managed-workload</h4><p><code>harness.io/managed-workload</code>:
    when you set this annotation to <code>true</code>, it informs Harness that this
    is a custom resource.</p><p>Here is an example:</p><pre>...<br/>    &#34;harness.io/managed-workload&#34;:
    &#34;true&#34;<br/>...</pre><h4>steadyStateCondition</h4><p><code>harness.io/steadyStateCondition</code>:
    since the resource is not a native Kubernetes resource, Harness needs a way to
    check its steady state.</p><p>Here is an example:</p><pre class="hljs sql">apiVersion:
    samplecontroller.k8s.io/v1alpha1<br/>kind: Foo<br/>metadata:<br/>  name: example-foo-demo<br/>  annotations:<br/>    &#34;harness.io/managed-workload&#34;:
    &#34;true&#34;<br/>    &#34;harness.io/steadyStateCondition&#34;: ${json.select(&#34;$..status.availableReplicas&#34;,
    response) == json.select(&#34;$..spec.replicas&#34;, response) &amp;&amp; json.select(&#34;$..spec.deploymentName&#34;,
    response) == &#34;example-foo-demo&#34;}<br/>spec:<br/>  deploymentName: example-foo-demo<br/>  replicas:
    2<br/>  template:<br/>    metadata:<br/>      labels: <br/>        &#34;harness.io/release-name&#34;:
    {{release}}<br/>...</pre><p></p><p>See Harness support for <a href="/article/wfvecw3yod-json-and-xml-functors">JSON
    and XML Functors</a>.</p><p>If the <code>steadyStateCondition</code> fails, Harness
    logs the following error message:</p><pre>Status check for resources in namespace
    [[namespace]] failed.</pre><h4>release-name</h4><p><code>harness.io/release-name:
    &lt;release_name&gt;</code> in labels: this is required for Harness to track any
    pods for the custom resource.</p><p>This label is used for redeploys (which Harness
    performs in place of rollbacks for CRDs).</p><p>In the even of deployment failure,
    Harness will redeploy the last successful release that matches the <code>release-name</code>
    label value (<code>harness.io/release-name: &lt;release_name&gt;</code>).</p><p>The
    <code>&lt;release_name&gt;</code> must match the <strong>Release Name</strong>
    in the Harness Infrastructure Definition. See <a href="/article/u3rp89v80h-define-your-kubernetes-target-infrastructure">Define
    Your Kubernetes Target Infrastructure</a>.</p><p>You declare the release name
    in the values.yaml, for example <code>release:release-${infra.kubernetes.infraId}</code>
    , and then reference it in the manifest as <code>{{.Values.release}}</code>.</p><p>Here
    is an example:</p><pre>...<br/>  labels:<br/>    &#34;harness.io/release-name&#34;:
    &#34;{{.Values.release}}&#34;<br/>...</pre><h4>Controller Must Add Release Name
    to Pods</h4><p>The CRD controller must add the <code>harness.io/release-name</code>
    label and value from the custom resource manifest to all the pods created for
    the custom resource. This process sets the label on the resource so Harness can
    track its releases.</p><p>This must be done programmatically by the controller.</p><p>Here
    is an example taken from the <a href="https://github.com/kubernetes/sample-controller/blob/master/controller.go#L391"
    target="_blank">Kubernetes sample controller on Github</a>:</p><pre>func newDeployment(foo
    *samplev1alpha1.Foo) *appsv1.Deployment {<br/><br/>  labelsFromSpec := foo.Spec.Template.Metadata.Labels<br/>  labels
    := map[string]string{<br/>    &#34;app&#34;:        &#34;nginx&#34;,<br/>    &#34;controller&#34;:
    foo.Name,<br/>  }<br/>  for k, v := range labelsFromSpec {<br/>    labels[k] =
    v<br/>  }<br/><br/>  klog.Info(&#34;Handle new deployment with labels: &#34;,
    labelsFromSpec)<br/>  return &amp;appsv1.Deployment{<br/>    ObjectMeta: metav1.ObjectMeta{<br/>      Name:      foo.Spec.DeploymentName,<br/>      Namespace:
    foo.Namespace,<br/>      OwnerReferences: []metav1.OwnerReference{<br/>        *metav1.NewControllerRef(foo,
    samplev1alpha1.SchemeGroupVersion.WithKind(&#34;Foo&#34;)),<br/>      },<br/>    },<br/>    Spec:
    appsv1.DeploymentSpec{<br/>      Replicas: foo.Spec.Replicas,<br/>      Selector:
    &amp;metav1.LabelSelector{<br/>        MatchLabels: labels,<br/>      },<br/>      Template:
    corev1.PodTemplateSpec{<br/>        ObjectMeta: metav1.ObjectMeta{<br/>          Labels:
    labels,<br/>        },<br/>        Spec: corev1.PodSpec{<br/>          Containers:
    []corev1.Container{<br/>            {<br/>              Name:  &#34;nginx&#34;,<br/>              Image:
    &#34;nginx:latest&#34;,<br/>            },<br/>          },<br/>        },<br/>      },<br/>    },<br/>  }<br/>}</pre><h4>Example
    Manifest</h4><p>Here is an example manifest:</p><pre>apiVersion: samplecontroller.k8s.io/v1alpha1<br/>kind:
    Foo<br/>metadata:<br/>  name: example-foo-demo<br/>  annotations:<br/>    &#34;harness.io/managed-workload&#34;:
    &#34;true&#34;<br/>    &#34;harness.io/steadyStateCondition&#34;: ${json.select(&#34;$..status.availableReplicas&#34;,
    response) == json.select(&#34;$..spec.replicas&#34;, response) &amp;&amp; json.select(&#34;$..spec.deploymentName&#34;,
    response) == &#34;example-foo-demo&#34;}<br/>spec:<br/>  deploymentName: example-foo-demo<br/>  replicas:
    2<br/>  template:<br/>    metadata:<br/>      labels: <br/>        &#34;harness.io/release-name&#34;:
    {{release}}</pre><p>As you can see in this example, steady state status is checked
    by verifying the replicas and name of the deployed custom resource.</p><h3>Step
    1: Prepare Target Cluster</h3><p>In most cases, the target deployment cluster
    will have the CustomResourceDefinition object already created. For example:</p><pre>apiVersion:
    apiextensions.k8s.io/v1beta1<br/>kind: CustomResourceDefinition<br/>metadata:<br/>  name:
    foos.samplecontroller.k8s.io<br/>spec:<br/>  group: samplecontroller.k8s.io<br/>  version:
    v1alpha1<br/>  names:<br/>    kind: Foo<br/>    plural: foos<br/>  scope: Namespaced</pre><p>After
    the CustomResourceDefinition object has been created in the cluster, you can create
    and deploy custom objects using Harness.</p><p>The <code>kind</code> field of
    the custom object comes from the spec of the CustomResourceDefinition object you
    created in your cluster.</p><p>For example:</p><pre>apiVersion: samplecontroller.k8s.io/v1alpha1<br/>kind:
    Foo<br/>metadata:<br/>  name: example-foo-demo<br/>  labels:<br/>    &#34;harness.io/release-name&#34;:
    &#34;{{.Values.release}}&#34;<br/>  annotations:<br/>    &#34;harness.io/managed-workload&#34;:
    &#34;true&#34;<br/>    &#34;harness.io/steadyStateCondition&#34;: ${json.select(&#34;$..status.availableReplicas&#34;,
    response) == json.select(&#34;$..spec.replicas&#34;, response) &amp;&amp; json.select(&#34;$..spec.deploymentName&#34;,
    response) == &#34;example-foo-demo&#34;}spec:<br/>  deploymentName: example-foo-demo<br/>  replicas:
    2</pre><p>Ensure your target cluster has the CRD for the custom resource object
    you will create in your deployment.</p><p>For an example of a simple CRD setup,
    see <a href="https://github.com/kubernetes/sample-controller">sample-controller</a>
    and <a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/"
    target="_blank">Extend the Kubernetes API with CustomResourceDefinitions</a> from
    Kubernetes.</p><h3>Step 2: Define Custom Resource in Harness</h3><p>You add the
    manifest for your custom object in a Harness Service, along with the artifact
    you will deploy. See <a href="/article/t6zrgqq0ny-kubernetes-services">Kubernetes
    Services</a>.</p><ol><li>In your Harness Application, click <strong>Services</strong>,
    and then <strong>Add Service</strong>.</li><li>Name your Service.</li><li>In <strong>Deployment
    Type</strong>, select <strong>Kubernetes</strong>.</li><li>Click Submit. The new
    Kubernetes Service appears.</li><li>Add an artifact, as described in <a href="/article/gxv9gj6khz-add-a-docker-image-service">Add
    a Docker Artifact Source</a>.</li><li>Next, you will add the manifest for the
    custom object In <strong>Manifests</strong>.</li><li>You can add your manifest
    inline, remotely, or by uploading. See <a href="/article/2j2vi5oxrq-define-kubernetes-manifests">Define
    Kubernetes Manifests</a>. You can also use <a href="/article/mwy6zgz8gu-use-go-templating-in-kubernetes-manifests">Go
    templating</a>.</li><li>Ensure your manifest has the required annotations and
    label, as described in <a href="#review_required_custom_resource_annotations_and_labels">Required
    Custom Resource Annotations and Labels</a>.</li></ol><p>When you are done your
    Service will look something like this:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/pmmfqqo1uh/1598041809772/image.png"/></figure><h3>Step
    3: Define Target Cluster</h3><p>In the same Harness Application, create your Kubernetes
    target cluster as described in <a href="/article/u3rp89v80h-define-your-kubernetes-target-infrastructure">Define
    Your Kubernetes Target Infrastructure</a>.</p><p>Ensure that the <strong>Release
    Name</strong> matches the name in the manifest&#39;s label, as described in <a
    href="#review_required_custom_resource_annotations_and_labels">Review: Required
    Custom Resource Annotations and Labels</a>:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/pmmfqqo1uh/1598042036463/image.png"/></figure><p></p><h3>Step
    4: Create Workflow for Custom Resource Deployment</h3><p>Only the Kubernetes Rolling
    deployment method is supported for CRDs. See <a href="/article/dl0l34ge8l-create-a-kubernetes-rolling-deployment">Create
    a Kubernetes Rolling Deployment</a>.</p><ol><li>In your Harness Application, click
    <strong>Workflows</strong>, and then click <strong>Add Workflow</strong>.</li><li>Name
    your Workflow.</li><li>In <strong>Workflow Deployment</strong>, select <strong>Rolling</strong>.</li><li>In
    <strong>Environment</strong>, select the Environment containing the Infrastructure
    Definition you set up for the target cluster where your CRD is defined.</li><li>In
    <strong>Service</strong>, select the Service with your custom object manifest.</li><li>In
    <strong>Infrastructure Definition</strong>, select the Infrastructure Definition
    you set up for the target cluster where your CRD is defined.</li><li>Click <strong>Submit</strong>.
    The Rolling deployment Workflow is created.</li></ol><p>There is nothing to configure
    in this Workflow unless you want to add additional steps. The default <strong>Rollout
    Deployment</strong> step will deploy your custom object.</p><p>You might want
    to run a <a href="/article/1fjrjbau7x-capture-shell-script-step-output">Shell
    Script</a> step to display additional Kubernetes information. See <a href="/article/7bpdtvhq92-workflow-variables-expressions">Kubernetes
    Workflow Variables and Expressions</a> for expressions you can use.</p><h3>Step
    5: Deploy Custom Resource</h3><p>Let&#39;s take a look at the logs from a CRD
    deployment.</p><h4>Initialize</h4><p>In the Initialize stage you can see that
    the release name has been added and a dry run was performed.</p><pre>...<br/>---<br/>apiVersion:
    samplecontroller.k8s.io/v1alpha1<br/>kind: Foo<br/>metadata:<br/>  name: example-foo-demo<br/>  labels:<br/>    &#34;harness.io/release-name&#34;:
    &#34;release-66259216-da29-35c4-ad4b-1053ffdaaf55&#34;<br/>  annotations:<br/>    &#34;harness.io/managed-workload&#34;:
    &#34;true&#34;<br/>    &#34;harness.io/steadyStateCondition&#34;: ${json.select(&#34;$..status.availableReplicas&#34;,
    response) == json.select(&#34;$..spec.replicas&#34;, response) &amp;&amp; json.select(&#34;$..spec.deploymentName&#34;,
    response) == &#34;example-foo-demo&#34;}<br/><br/>spec:<br/>  deploymentName:
    example-foo-demo<br/>  replicas: 2<br/><br/><br/>Validating manifests with Dry
    Run<br/><br/>kubectl --kubeconfig=config apply --filename=manifests-dry-run.yaml
    --dry-run<br/><br/>namespace/default configured (dry run)<br/>secret/harness-example
    configured (dry run)<br/>configmap/harness-example created (dry run)<br/>service/harness-example-svc
    configured (dry run)<br/>deployment.apps/harness-example-deployment configured
    (dry run)<br/>foo.samplecontroller.k8s.io/example-foo-demo configured (dry run)<br/></pre><p></p><h4>Prepare</h4><p>In
    the Prepare stage the manifests are processed and the workloads are identified:</p><pre>Manifests
    processed. Found following resources: <br/><br/>Kind                Name                                    Versioned
    <br/>Namespace           default                                 false     <br/>Secret              harness-example                         true      <br/>ConfigMap           harness-example                         true      <br/>Service             harness-example-svc                     false     <br/>Deployment          harness-example-deployment              false     <br/>Foo                 example-foo-demo                        false     <br/><br/>Current
    release number is: 8<br/><br/>Previous Successful Release is 7<br/>...<br/>Found
    following Managed Workloads: <br/><br/>Kind                Name                                    Versioned
    <br/>Deployment          harness-example-deployment              false     <br/>Foo                 example-foo-demo                        false     <br/><br/>Versioning
    resources.<br/><br/>Done</pre><p>Notice that the custom object is identified by
    its CRD in <strong>Kind</strong>.</p><h4>Apply</h4><p>The Apply stage runs a <a
    href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#kubectl-apply">kubectl
    apply</a> using the manifests:</p><pre>kubectl --kubeconfig=config apply --filename=manifests.yaml
    --record<br/><br/>namespace/default unchanged<br/>secret/harness-example-8 configured<br/>configmap/harness-example-8
    created<br/>service/harness-example-svc unchanged<br/>deployment.apps/harness-example-deployment
    configured<br/>foo.samplecontroller.k8s.io/example-foo-demo configured<br/><br/>Done.</pre><p>As
    this is the first deployment, the new object is identified as <strong>configured</strong>.</p><h4>Wait
    for Steady State</h4><p>This stage performs a <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#get">kubectl
    get</a> to display status about the custom resource.</p><pre>...<br/>Status :
    example-foo-demo               &#34;kubernetes.io/change-cause&#34;: &#34;kubectl
    apply --kubeconfig=config --filename=manifests.yaml --record=true&#34;<br/><br/>Status
    : example-foo-demo           },<br/><br/>Status : example-foo-demo           &#34;creationTimestamp&#34;:
    &#34;2020-07-21T09:55:42Z&#34;,<br/><br/>Status : example-foo-demo           &#34;generation&#34;:
    11,<br/><br/>Status : example-foo-demo           &#34;name&#34;: &#34;example-foo-demo&#34;,<br/><br/>Status
    : example-foo-demo           &#34;namespace&#34;: &#34;default&#34;,<br/><br/>Status
    : example-foo-demo           &#34;resourceVersion&#34;: &#34;119096798&#34;,<br/><br/>Status
    : example-foo-demo           &#34;selfLink&#34;: &#34;/apis/samplecontroller.k8s.io/v1alpha1/namespaces/default/foos/example-foo-demo&#34;,<br/><br/>Status
    : example-foo-demo           &#34;uid&#34;: &#34;f2e2847e-bfa8-4242-9354-db8c83c57df1&#34;<br/><br/>Status
    : example-foo-demo       },<br/><br/>Status : example-foo-demo       &#34;spec&#34;:
    {<br/><br/>Status : example-foo-demo           &#34;deploymentName&#34;: &#34;example-foo-demo&#34;,<br/><br/>Status
    : example-foo-demo           &#34;replicas&#34;: 2<br/><br/>Status : example-foo-demo       },<br/><br/>Status
    : example-foo-demo       &#34;status&#34;: {<br/><br/>Status : example-foo-demo           &#34;availableReplicas&#34;:
    2<br/><br/>Status : example-foo-demo       }<br/><br/>Status : example-foo-demo   }<br/><br/>Done.</pre><p></p><h4>Wrap
    Up</h4><p>Finally, the Wrap Up stage shows the deployed custom object:</p><pre>...<br/>Name:         example-foo-demo<br/>Namespace:    default<br/>Labels:       harness.io/release-name:
    release-66259216-da29-35c4-ad4b-1053ffdaaf55<br/>Annotations:  harness.io/managed-workload:
    true<br/>              harness.io/steadyStateCondition:<br/>                ${json.select(&#34;$..status.availableReplicas&#34;,
    response) == json.select(&#34;$..spec.replicas&#34;, response) &amp;&amp; json.select(&#34;$..spec.deploymentName...<br/>              kubectl.kubernetes.io/last-applied-configuration:<br/>                {&#34;apiVersion&#34;:&#34;samplecontroller.k8s.io/v1alpha1&#34;,&#34;kind&#34;:&#34;Foo&#34;,&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;harness.io/managed-workload&#34;:&#34;true&#34;,&#34;harness.io/...<br/>              kubernetes.io/change-cause:
    kubectl apply --kubeconfig=config --filename=manifests.yaml --record=true<br/>API
    Version:  samplecontroller.k8s.io/v1alpha1<br/>Kind:         Foo<br/>Metadata:<br/>  Creation
    Timestamp:  2020-07-21T09:55:42Z<br/>  Generation:          11<br/>  Resource
    Version:    119096798<br/>  Self Link:           /apis/samplecontroller.k8s.io/v1alpha1/namespaces/default/foos/example-foo-demo<br/>  UID:                 f2e2847e-bfa8-4242-9354-db8c83c57df1<br/>Spec:<br/>  Deployment
    Name:  example-foo-demo<br/>  Replicas:         2<br/>Status:<br/>  Available
    Replicas:  2<br/>Events:<br/>  Type    Reason  Age                  From               Message<br/>  ----    ------  ----                 ----               -------<br/>  Normal  Synced  15s
    (x135 over 98m)  sample-controller  Foo synced successfully<br/><br/>Done.</pre><p></p><h3>See
    Also</h3><ul><li> <a href="/article/78oginrhsh-delete-kubernetes-resources">Delete
    Kubernetes Resources</a></li><li> <a href="/article/4vjgmjcj6z-deploy-manifests-separately-using-apply-step">Deploy
    Manifests Separately using Apply Step</a></li><li> <a href="/article/va3trqfy49-scale-kubernetes-pods">Scale
    Kubernetes Pods</a></li></ul><h3>Configure As Code</h3><p>To see how to configure
    the settings in this topic using YAML, configure the settings in the UI first,
    and then click the YAML editor button (<span style="color:#fb9e00" data-hd-color="#fb9e00"><strong>&lt;/&gt;</strong></span>).</p>'
  slug: create-kubernetes-crd-deployments
  tags: []
  is_live: true
