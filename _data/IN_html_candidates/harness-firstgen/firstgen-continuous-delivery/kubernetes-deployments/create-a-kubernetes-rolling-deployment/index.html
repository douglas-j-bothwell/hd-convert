<p></p><div class="tip-callout">This content is for Harness <a href="/article/1fjmm4by22">FirstGen</a>. Switch to <a href="/article/xsla71qg8t">NextGen</a>.</div><p>A rolling update strategy updates Kubernetes deployments with zero downtime by incrementally updating pods instances with new ones. New Pods are scheduled on nodes with available resources.</p><p>This method is similar to a standard Canary strategy, but different to Harness Kubernetes Canary strategy. The Harness Kubernetes Canary strategy uses a rolling update as its final phase. See <a href="/article/2xp0oyubjj-create-a-kubernetes-canary-deployment">Create a Kubernetes Canary Deployment</a> for more information.</p><div class="note-callout">For a detailed explanation of Kubernetes rolling updates, see <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/">Performing a Rolling Update</a> from Kubernetes.</div><p>In this topic:</p><ul><li> <a href="#before_you_begin">Before You Begin</a></li><li> <a href="#review_what_workloads_can_i_deploy">Review: What Workloads Can I Deploy?</a></li><li> <a href="#step_1_define_rollout_strategy">Step 1: Define Rollout Strategy</a></li><li> <a href="#step_2_create_workflow">Step 2: Create Workflow</a></li><li> <a href="#step_3_rollout_deployment_step">Step 3: Rollout Deployment Step</a></li><li> <a href="#example_rolling_update_deployment">Example: Rolling Update Deployment</a></li><li> <a href="#kubernetes_rollback">Kubernetes Rollback</a></li><li> <a href="#next_steps">Next Steps</a></li></ul><h3>Before You Begin</h3><ul><li> <a href="/article/2j2vi5oxrq-define-kubernetes-manifests">Define Kubernetes Manifests</a></li><li> <a href="/article/u3rp89v80h-define-your-kubernetes-target-infrastructure">Define Your Kubernetes Target Infrastructure</a></li></ul><h3>Review: What Workloads Can I Deploy?</h3><p>See <a href="/article/6ujb3c70fh">What Can I Deploy in Kubernetes?</a>.</p><h4>Multiple Managed Workloads</h4><p>For Rolling Update deployments, you can deploy multiple managed workloads.</p><p>For Canary and Blue/Green Workflow deployments, only one managed object may be deployed per Workflow by default. You can deploy additional objects using the <a href="/article/4vjgmjcj6z-deploy-manifests-separately-using-apply-step">Apply Step</a>, but it is typically used for deploying Jobs controllers.</p><div class="note-callout">You can specify the multiple workload objects in a single manifest or in individual manifests, or any other arrangement.</div><p>For example, here is a Service <strong>Manifests</strong> section with two Deployment objects, each in their own manifest:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/5gouaz9w5r/1562025002754/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>Here is the log from the deployment, where you can see both Deployment objects deployed:</p><pre>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: anshul-multiple-workloads-deployment<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: anshul-multiple-workloads<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: anshul-multiple-workloads<br/>    spec:<br/>      containers:<br/>      - name: anshul-multiple-workloads<br/>        image: registry.hub.docker.com/library/nginx:stable<br/>        envFrom:<br/>        - configMapRef:<br/>            name: anshul-multiple-workloads<br/>        - secretRef:<br/>            name: anshul-multiple-workloads<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: anshul-multiple-workloads-deployment-1<br/>spec:<br/>  replicas: 3<br/>  selector:<br/>    matchLabels:<br/>      app: anshul-multiple-workloads<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: anshul-multiple-workloads<br/>    spec:<br/>      containers:<br/>      - name: anshul-multiple-workloads<br/>        image: registry.hub.docker.com/library/nginx:stable<br/>        envFrom:<br/>        - configMapRef:<br/>            name: anshul-multiple-workloads<br/>        - secretRef:<br/>            name: anshul-multiple-workloads</pre><p></p><h3>Step 1: Define Rollout Strategy</h3><p>There are no mandatory Rolling Update–specific settings for manifests in the Harness Service. You can use any Kubernetes configuration in your Service <strong>Manifests</strong> section.</p><p>The default Rolling Update strategy used by Harness is:</p><pre class="hljs http">RollingUpdateStrategy:  25% max unavailable, 25% max surge</pre><p>If you want to set a Rolling Update strategy that is different from the default, you can include the strategy settings in your Deployment manifest:</p><pre class="hljs properties">strategy:<br/>  type: RollingUpdate<br/>  rollingUpdate:<br/>    maxSurge: 1<br/>    maxUnavailable: 1</pre><p>For details on the settings, see RollingUpdateDeployment in the <a href="https://kubernetes.io/docs/concepts/overview/kubernetes-api/">Kubernetes API docs</a>.</p><h3>Step 2: Create Workflow</h3><ol><li>In your Application containing a completed Service and Environment for the Rollout Deployment, click <strong>Workflows</strong>.</li><li>Click <strong>Add Workflow</strong>. The <strong>Workflow</strong> dialog appears.</li><li>In <strong>Name</strong>, enter a name for your Workflow.</li><li>In <strong>Workflow Type</strong>, select <strong>Rolling Deployment</strong>.</li><li>In <strong>Environment</strong>, select the Environment you created for your Kubernetes deployment.</li><li>In <strong>Service</strong>, select the Service containing the manifest files you want to use for your deployment.</li><li>In Infrastructure Definition, select the Infrastructure Definition where you want to deploy.</li><li>When you are finished, the <strong>Workflow</strong> dialog will look like this example:<figure><img src="https://files.helpdocs.io/kw8ldg1itf/other/1568671934060/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure></li><li>Click <strong>SUBMIT</strong>. The new Workflow appears.</li></ol><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550439416392/image.png"><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550439416392/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></a></figure><p></p><h3>Step 3: Rollout Deployment Step</h3><p>The Workflow generates the <strong>Rollout Deployment</strong> step automatically. There&#39;s nothing to update. You can deploy the Workflow.</p><p>The Rollout Deployment step includes the following options.</p><h4>Manifest Options</h4><div class="note-callout">Currently, this feature is behind the Feature Flag <code>KUBERNETES_EXPORT_MANIFESTS</code>. Contact <a href="mailto:support@harness.io" target="_blank">Harness Support</a> to enable the feature.</div><h5>Export Manifest</h5><p>If you enable this option, Harness does the following at runtime:</p><ul><li>Downloads manifests (if remote).</li><li>Renders manifests in logs.</li><li>Performs a dry run unless the <strong>Skip Dry Run</strong> option is enabled.</li><li>Export the deployment manifests to the variable <code>${k8sResources.manifests}</code>.</li><li><strong>Does not deploy the manifests.</strong> To deploy the manifests, you must add another Kubernetes step of the same type (Canary, Rolling, Apply, Stage Deployment) an enable the <strong>Inherit Manifest</strong> option to deploy a copy of the exported manifests.</li></ul><p>If <strong>Export Manifest</strong> is enabled, the manifests are not deployed. You can use the <strong>Inherit Manifest</strong> option in a subsequent Kubernetes step to deploy a copy of the exported manifests.</p><p>The exported manifests can be written to storage on the Delegate where the step is run. For example, you can add a <a href="/article/1fjrjbau7x-capture-shell-script-step-output">Shell Script</a> step to echo and write the manifest to a file:</p><pre>echo &#34;${k8sResources.manifests}&#34; &gt; /opt/harness-delegate/test/canaryPlan</pre><p></p><div class="note-callout">If you use <code>${k8sResources.manifests}</code> in a script ensure that your script expects multiline output. You can use <code>cat</code> command to concatenate the lines.</div><p></p><p>If you have the 3rd party tool that check compliance, it can use the exported manifests.</p><p>To deploy the manifests, a copy of the exported manifests can be inherited by the next Kubernetes step (Canary, Rolling, Apply, Stage Deployment) using the <strong>Inherit Manifest</strong> option.</p><p>If <strong>Export Manifest</strong> is enabled in multiple Kubernetes steps of the same type in the same Workflow Phase, the last step overrides the exported manifests. This is important because the next Kubernetes step to inherit a copy of the exported manifests will only use the exported manifests from last Kubernetes step with <strong>Export Manifest</strong> is enabled.</p><h5>Inherit Manifest</h5><p>Enable this option to inherit and deploy a copy of the manifests exported from the previous Kubernetes step (Canary, Rolling, Apply, Stage Deployment) using the <strong>Export Manifest</strong> option.</p><p>The <strong>Inherit Manifest</strong> option will only inherit the exported manifest from the last Kubernetes step of the same type and in the same Workflow Phase.</p><p>For example, if you enable the <strong>Inherit Manifest</strong> option in a <strong>Canary Deployment</strong> step, then it will only inherit a copy of the manifests exported from the last <strong>Canary Deployment</strong> step with the <strong>Export Manifest</strong> option enabled in the same Workflow Phase.</p><h4>Skip Dry Run</h4><p>By default, Harness uses the <code>--dry-run</code> flag on the <code>kubectl apply</code> command during the <strong>Initialize</strong> step of this command, which prints the object that would be sent to the cluster without really sending it. If the <strong>Skip Dry Run</strong> option is selected, Harness will not use the <code>--dry-run</code> flag.</p><p>Let&#39;s look at what the <strong>Rollout Deployment</strong> step does in the deployment logs.</p><h4>Delegate Selector</h4><p>If your Workflow Infrastructure Definition&#39;s Cloud Provider uses a Delegate Selector (supported in Kubernetes Cluster and AWS Cloud Providers), then the Workflow uses the selected Delegate for all of its steps.</p><p>In these cases, you shouldn&#39;t add a Delegate Selector to any step in the Workflow. The Workflow is already using a Selector via its Infrastructure Definition&#39;s Cloud Provider.</p><p>If your Workflow Infrastructure Definition&#39;s Cloud Provider isn&#39;t using a Delegate Selector, and you want this Workflow step to use a specific Delegate, do the following:</p><p>In <strong>Delegate Selector</strong>, select the Selector for the Delegate(s) you want to use. You add Selectors to Delegates to make sure that they&#39;re used to execute the command. For more information, see <a href="https://docs.harness.io/article/c3fvixpgsl-select-delegates-for-specific-tasks-with-selectors">Select Delegates for Specific Tasks with Selectors</a>.</p><p>Harness will use Delegates matching the Selectors you add.</p><p>If you use one Selector, Harness will use any Delegate that has that Selector.</p><p>If you select two Selectors, a Delegate must have both Selectors to be selected. That Delegate might also have other Selectors, but it must have the two you selected.</p><div class="note-callout">You can use expressions for Harness built-in variables or Account Default variables in <strong>Delegate Selectors</strong>. When the variable expression is resolved at deployment runtime, it must match an existing Delegate Selector.<br/><br/>For example, if you have a Delegate Selector <strong>prod</strong> and the Workflow is using an Environment also named <strong>prod</strong>, the Delegate Selector can be <code>${env.name}</code>. This is very useful when you match Delegate Selectors to Application component names such as Environments, Services, etc. It&#39;s also a way to template the Delegate Selector setting.</div><p></p><h4>Apply Section in Deployment</h4><p>The Apply section deploys the manifests from the Service <strong>Manifests</strong> section as one file.</p><pre class="hljs nginx">kubectl --kubeconfig=config apply --filename=manifests.yaml --record<br/><br/>configmap/harness-example-config-3 configured<br/>deployment.apps/harness-example-deployment created<br/><br/>Done.</pre><h4>Wait for Steady State Section in Deployment</h4><p>The Wait for Steady State section shows the containers and pods rolled out.</p><pre class="hljs coffeescript">kubectl --kubeconfig=config get events --output=custom-columns=KIND:involvedObject.kind,NAME:.involvedObject.name,MESSAGE:.message,REASON:.reason --watch-only<br/><br/>kubectl --kubeconfig=config rollout status Deployment/harness-example-deployment --watch=true<br/><br/><br/>Status : Waiting for deployment &#34;harness-example-deployment&#34; rollout to finish: 0 of 2 updated replicas are available...<br/>Event  : Pod    harness-example-deployment-5674658766-6b2fw   Successfully pulled image &#34;registry.hub.docker.com/library/nginx:stable-perl&#34;   Pulled<br/>Event  : Pod   harness-example-deployment-5674658766-p9lpz   Successfully pulled image &#34;registry.hub.docker.com/library/nginx:stable-perl&#34;   Pulled<br/>Event  : Pod   harness-example-deployment-5674658766-6b2fw   Created container   Created<br/>Event  : Pod   harness-example-deployment-5674658766-p9lpz   Created container   Created<br/>Event  : Pod   harness-example-deployment-5674658766-6b2fw   Started container   Started<br/>Event  : Pod   harness-example-deployment-5674658766-p9lpz   Started container   Started<br/><br/>Status : Waiting for deployment &#34;harness-example-deployment&#34; rollout to finish: 1 of 2 updated replicas are available...<br/><br/>Status : deployment &#34;harness-example-deployment&#34; successfully rolled out<br/><br/>Done.</pre><h4>Wrap Up Section in Deployment</h4><p>The Wrap Up section shows the Rolling Update strategy used.</p><pre class="hljs makefile">...<br/>Name:                   harness-example-deployment<br/>Namespace:              default<br/>CreationTimestamp:      Sun, 17 Feb 2019 22:03:53 +0000<br/>Labels:                 &lt;none&gt;<br/>Annotations:            deployment.kubernetes.io/revision: 1<br/>                        kubectl.kubernetes.io/last-applied-configuration:<br/>                          {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;kubernetes.io/change-cause&#34;:&#34;kubectl apply --kubeconfig=config --f...<br/>                        kubernetes.io/change-cause: kubectl apply --kubeconfig=config --filename=manifests.yaml --record=true<br/>Selector:               app=harness-example<br/>Replicas:               2 desired | 2 updated | 2 total | 2 available | 0 unavailable<br/>StrategyType:           RollingUpdate<br/>MinReadySeconds:        0<br/>RollingUpdateStrategy:  25% max unavailable, 25% max surge<br/>...<br/>NewReplicaSet:   harness-example-deployment-5674658766 (2/2 replicas created)<br/>Events:<br/>  Type    Reason             Age   From                   Message<br/>  ----    ------             ----  ----                   -------<br/>  Normal  ScalingReplicaSet  8s    deployment-controller  Scaled up replica set harness-example-deployment-5674658766 to 2<br/><br/>Done.</pre><h3>Example: Rolling Update Deployment</h3><p>Now that the setup is complete, you can click <strong>Deploy</strong> in the Workflow to deploy the artifact to your cluster.</p><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550514972283/image.png"><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550514972283/image.png"/></a></figure><p>Next, select the artifact build version and click <strong>SUBMIT</strong>.</p><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550515038984/image.png"><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550515038984/image.png"/></a></figure><p>The Workflow is deployed.</p><p>To see the completed deployment, log into your cluster and run <code>kubectl get all</code>. The output lists the new Deployment:</p><pre class="hljs properties">NAME                                                   READY     STATUS    RESTARTS   AGE<br/>pod/harness-example-deployment-5674658766-6b2fw        1/1       Running   0          34m<br/>pod/harness-example-deployment-5674658766-p9lpz        1/1       Running   0          34m<br/>                                                       <br/>NAME                                                   TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)        AGE<br/>service/kubernetes                                     ClusterIP      10.83.240.1     &lt;none&gt;           443/TCP        34m<br/>                                                       <br/>NAME                                                   DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/harness-example-deployment             2         2         2            2           34m<br/>                                                       <br/>NAME                                                   DESIRED   CURRENT   READY     AGE<br/>replicaset.apps/harness-example-deployment-5674658766  2         2         2         34m</pre><p></p><h3>Kubernetes Rollback</h3><p>See <a href="/article/v41e8oo00e-kubernetes-rollback">Kubernetes Rollback</a>.</p><p>You can add a <strong>Rollback Deployment</strong> command to the <strong>Rollback Steps</strong> in your Workflow to roll back the workloads deployed by the <strong>Rollout Deployment</strong> step.</p><p>Simply add this command to the <strong>Rollback Steps</strong> in a Workflow where you want to initiate a rollback. Note that this command applies to the deployments of the Rollout Deployment command, and not the <a href="/article/4vjgmjcj6z-deploy-manifests-separately-using-apply-step">Apply Step</a> command.</p><h3>Next Steps</h3><ul><li> <a href="/article/ukftzrngr1-create-a-kubernetes-blue-green-deployment">Create a Kubernetes Blue/Green Deployment</a></li></ul><p></p>