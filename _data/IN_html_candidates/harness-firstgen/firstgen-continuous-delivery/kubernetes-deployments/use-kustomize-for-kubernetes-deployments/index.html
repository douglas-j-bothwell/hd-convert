<p>Harness supports <a href="https://kustomize.io/" target="_blank">Kustomize</a> kustomizations in your Kubernetes deployments. You can use overlays, multibase, plugins, sealed secrets, etc, just as you would in any native kustomization.</p><div class="note-callout"><strong>New to Kustomize?</strong> In a nutshell, kustomizations let you create specific Kubernetes deployments while leaving the original manifests untouched. You drop a kustomization.yaml file next to your Kubernetes YAML files and it defines new behavior to be performed during deployment.<br/>Please review the video <a href="https://youtu.be/ahMIBxufNR0" target="_blank">Kustomize: Deploy Your App with Template Free YAML</a> (30min), the <a href="https://kubectl.docs.kubernetes.io/references/kustomize/glossary/" target="_blank">Kustomize Glossary</a>, and the <a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/" target="_blank">Declarative Management of Kubernetes Objects Using Kustomize</a>.</div><p></p><h3>Before You Begin</h3><ul><li> <a href="/article/m383u53mp1-connect-to-your-target-kubernetes-platform">Connect to Your Target Kubernetes Platform</a></li><li> <a href="/article/7in9z2boh6-kubernetes-quickstart">Kubernetes Quickstart</a></li></ul><div class="note-callout">Kustomize is supported in Harness Kubernetes v2 Services only. This is the default type, but some Harness users might be using a legacy Kubernetes v1 Service.</div><h3>Visual Summary</h3><p>The following diagram shows a very simple topology for implementing Kustomize.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582677066267/image.png"/></figure><p>The Harness Kubernetes Delegate runs in the target cluster with Kustomize pre-installed. The Delegate obtains kustomization.yaml and resource files from a Git repo. The Delegate deploys the Kubernetes objects declared using Kustomize in the target pods.</p><p>In this diagram we use Google GCP, but Harness deploys to any Kubernetes cluster vendor.</p><h4>Video Summary</h4><p></p><div class="hd--html"><iframe width="560" height="315" src="https://www.youtube.com/embed/BlxPanrpaX0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p></p><h3>Limitations</h3><p>Currently, Harness support for Kustomize has the following limitations:</p><ul><li>Harness variables and secrets are not supported.<ul><li>Harness variables are not supported because Kustomize follows a template-free methodology.</li><li>Use <a href="https://github.com/bitnami-labs/sealed-secrets" target="_blank">sealed secrets</a> instead. See <strong>Sealed Secrets</strong> in <a href="https://learnk8s.io/kubernetes-secrets-in-git" target="_blank">How to keep your Kubernetes secrets secure in Git</a> by Omer Levi Hevroni.</li></ul></li><li>Harness artifacts are not supported, as described in <a href="#review_artifact_sources_and_kustomization">Review: Artifact Sources and Kustomization</a>.</li><li>Harness does not use Kustomize for rollback. Harness renders the templates using Kustomize and then passes them onto kubectl. A rollback works exactly as it does for native Kubernetes.</li></ul><h3>Review: Kustomize and Harness Delegates</h3><p>All Harness Delegates include kustomize by default. There is no installation required.</p><p>Your Delegate hosts, typically a pod in the target cluster, require outbound HTTPS/SSH connectivity to Harness and your Git repo.</p><div class="note-callout">The Delegate you use for Kustomize deployments must have access to the Git repo containing your kustomize and resource files.</div><p>The remainder of this topic assumes you have a running Harness Delegate and Cloud Provider connection. For details on setting those up, see <a href="/article/m383u53mp1-connect-to-your-target-kubernetes-platform">Connect to Your Target Kubernetes Platform</a>.</p><h3>Step 1: Connect to Your Kustomize Repo</h3><p>You add a connection to the repo containing your kustomize and resource files as a Harness Source Repo Provider.</p><p>For details on adding a Source Repro Provider, see <a href="/article/ay9hlwbgwa-add-source-repo-providers">Add Source Repo Providers</a>.</p><p>Here is a quick summary:</p><ol><li>In Harness, click <strong>Setup</strong>, and then <strong>Connectors</strong>.</li><li>Click <strong>Source Repo Providers</strong>, and then click <strong>Add Source Repo Provider</strong>.</li><li>Provide the following settings and click <strong>Submit</strong>:</li></ol><p></p><table><tbody><tr><td><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582583867062/image.png"/></figure></td><td><ul><li><strong>Display Name:</strong> You will use this name to select the repo in your Harness Service.</li><li><strong>URL:</strong> Provide the Git repo URL.</li><li><strong>Username/password:</strong> Enter your Git credentials.</li><li><strong>Branch:</strong> Enter the name of the branch you want to use, such as <strong>master</strong>.</li></ul></td></tr></tbody></table><p></p><div class="note-callout">The Delegate you use for Kustomize deployments must have access to the Git repo containing your kustomize and resource files.</div><p>Now you have a connection to your kustomize and resource files. Next, you can identify these files as Remote Manifests in a Harness Service.</p><p>The following steps assume you have created a Harness Service for your Kubernetes deployment. For details, see <a href="/article/2j2vi5oxrq-define-kubernetes-manifests#step_1_create_the_harness_kubernetes_service">Create the Harness Kubernetes Service</a>.</p><p></p><h3>Review: Artifact Sources and Kustomization</h3><p>Typically, Harness Services are configured with an Artifact Source. This is the container image or other artifact that Harness will deploy. For Kustomize, you do not specify an Artifact Source in your Harness Service.</p><p>The artifact you want to deploy must be specified in a spec (for example, deployment.yaml). If the image is in the public Docker hub repo, you can just list its name:</p><pre>...<br/>spec:<br/>  containers:<br/>  - name: app<br/>    image: pseudo/your-image:latest<br/>...</pre><p>If your image is hosted in aÂ private Docker hub repo, you need to specify an <a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/" target="_blank">imagePullSecrets</a> in the spec field:</p><pre>...<br/>spec:<br/>  containers:<br/>  - name: app<br/>    image: pseudo/your-image:latest<br/>  imagePullSecrets:<br/>  - name: dockerhub-credential<br/> ...</pre><p></p><h3>Step 2: Add Manifests and Kustomization</h3><ol><li>In your Harness Service, in <strong>Manifests</strong>, click <strong>Link Remote Manifests</strong>.</li></ol><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582584606916/image.png" style="max-height:25%;max-width:25%" data-hd-height="25%" data-hd-width="25%"/></figure><ol><li style="counter-increment:li 1" start="2">In <strong>Remote Manifests</strong>, in <strong>Manifest Format</strong>, click <strong>Kustomization Configuration</strong>.</li><li>Enter the following settings and click <strong>Submit</strong>.</li></ol><p></p><table><tbody><tr><td><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1586333690469/screenshot-2020-04-08-at-1-35-46-pm.png"/></figure></td><td><ul><li><strong>Source Repository:</strong> Select the Source Repo Provider connection to your repo.</li><li><strong>Commit ID:</strong> Select <strong>Latest from Branch</strong> or <strong>Specific Commit ID</strong>. Do one of the following:<ul><li><strong>Branch:</strong> Enter the branch name, such as <strong>master</strong>.</li><li><strong>Commit ID:</strong> Enter the Git commit ID.</li></ul></li><li><strong>Path to kustomization directory:</strong> This setting is discussed below.</li><li><strong>Path to Kustomize plugin on Delegate:</strong> Enter the path to the plugin installed on the Delegate. This setting and using plugins are discussed later in this topic.</li></ul></td></tr></tbody></table><p></p><p>Once you have set up <strong>Kustomization Configuration</strong>, you can use the Service in a Harness Workflow. There are no other Kustomize-specific settings to configure in Harness.</p><h4>Path to Kustomization Directory</h4><p>You can manually enter the file path to your <a href="https://kubectl.docs.kubernetes.io/references/kustomize/glossary/#kustomization-root" target="_blank">kustomization root</a>: The directory that contains a kustomization.yaml file in your repo. You do not need to enter the filename.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1583175996804/image.png"/></figure><p>If you are using overlays, enter the path to the overlay kustomization.yaml.</p><p>As explained below, you can use Harness variable expressions in <strong>Path to kustomization directory</strong> to dynamically select bases for overlays.</p><h4>Skip Versioning for Service</h4><p>By default, Harness versions ConfigMaps and Secrets deployed into Kubernetes clusters. In some cases, you might want to skip versioning.</p><p>Typically, to skip versioning in your deployments, you add the annotation <code>harness.io/skip-file-for-deploy</code> to your manifests. See <a href="/article/4vjgmjcj6z-deploy-manifests-separately-using-apply-step">Deploy Manifests Separately using Apply Step</a>.</p><p>In some cases, such as when using public manifests or Helm charts, you cannot add the annotation. Or you might have 100 manifests and you only want to skip versioning for 50 of them. Adding the annotation to 50 manifests is time-consuming.</p><p>Instead, enable the <strong>Skip Versioning for Service</strong> option in <strong>Remote Manifests</strong>.</p><p>When you enable <strong>Skip Versioning for Service</strong>, Harness will not perform versioning of ConfigMaps and Secrets for the Service.</p><p>If you have enabled <strong>Skip Versioning for Service</strong> for a few deployments and then disable it, Harness will start versioning ConfigMaps and Secrets.</p><h4 id="undefined">Review: Artifact Sources and Kustomization</h4><p>You can list artifacts in two ways:</p><ul><li>Artifacts can be hardcoded in the deployment YAML file deployed using your Kustomization files.</li><li>You can add artifacts to the ServiceÂ <strong>Artifact Source</strong>Â section and reference them in Kustomize Patch files using the Harness variableÂ <code>${artifact.metadata.image}</code>. SeeÂ <a href="#option_kustomize_patches">Option: Kustomize Patches</a>Â below, andÂ <a href="/article/aza65y4af6-built-in-variables-list">Built-in Variables List</a>.</li></ul><h3>Option: Kustomize Patches</h3><div class="note-callout">Currently, this feature is behind the Feature FlagÂ <code>KUSTOMIZE_PATCHES_CG</code>. ContactÂ <a href="mailto:support@harness.io" target="_blank">Harness Support</a>Â to enable the feature. When you enable this Feature Flag, you will be able to use Kustomize version 4.0.0.</div><div class="warning-callout">You cannot use Harness variables in the base manifest or kustomization.yaml. You can only use Harness variables in kustomize patches you add inÂ <strong>Kustomize Patches</strong>.</div><p>Kustomize patches override values in the base manifest. Harness supports theÂ <code>patchesStrategicMerge</code>Â patches type.</p><p>For example, let&#39;s say you have a simple kustomization.yaml for yourÂ <strong>application</strong>Â folder like this:</p><pre class="hljs markdown">resources:<br/>  - namespace.yaml<br/>  - deployment.yaml<br/>  - service.yaml<br/>  - configmap.yaml</pre><p>And you have an overlay for a production environment that points to theÂ <strong>application</strong>Â folder like this:</p><pre class="hljs yaml">resources:<br/>  - ../../application<br/>namePrefix: nonpro-<br/>configMapGenerator:<br/>- name: example-config<br/>  namespace: default<br/>  #behavior: replace<br/>  files:<br/>    - configs/config.json<br/>patchesStrategicMerge:<br/>  - env.yaml</pre><p>TheÂ <code>patchesStrategicMerge</code>Â label identifies the location of the patchÂ <strong>env.yaml</strong>, which looks like this:</p><pre class="hljs yaml">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: example-deploy<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>      - name: example-app<br/>        env:<br/>        - name: ENVIRONMENT<br/>          value: Production</pre><p>As you can see, it patches a new environment variableÂ <code>name: ENVIRONMENT</code>.</p><p>Here&#39;s what the patching looks like side-by-side:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1642111092925/image.png"/></figure><p>When the kustomization.yaml is deployed, the patch is rendered and the environment variable is added to the deployment.yaml that is deployed.</p><h4 id="undefined">Adding Kustomize Patches</h4><div class="warning-callout">You cannot use Harness variables in the base manifest or kustomization.yaml. You can only use Harness variables in kustomize patches you add inÂ <strong>Kustomize Patches</strong>.</div><p>In <strong>Service</strong>, inÂ <strong>Configuration</strong>, inÂ <strong>Kustomize Patches</strong>, click <strong>Add Patches</strong>.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1642111167347/clean-shot-2022-01-13-at-13-59-04.png"/></figure><div class="note-callout">You can add multiple files by using <strong>Add Patches</strong> multiple times.</div><p>In <strong>Store Type</strong>, select <strong>Inline</strong> or <strong>Remote</strong>.</p><p>For <strong>Inline</strong>, enter the patch YAML, and click <strong>Submit</strong>.</p><p>For <strong>Remote</strong>, in <strong>Source Repository</strong>, select your Source Repo Connector. See <a href="/article/ay9hlwbgwa-add-source-repo-providers">Add Source Repo Providers</a>.</p><p>For Commit ID,Â select whether to use the latest branch or a specific commit Id/Git tag.</p><p>In <strong>Branch</strong>/<strong>Commit Id</strong>: enter the branch or commit Id/Git tag.</p><p>In <strong>File/Folder Path:</strong>Â enter the path to the patch file(s) from the root of the repo. The file you add should be the same file listed inÂ <code>patchesStrategicMerge</code>Â of the main kustomize file in your Service.</p><div class="note-callout">You can add multiple files by using <strong>Add Patches</strong> multiple times.</div><div class="note-callout">The order in which you add file paths for patches inÂ <strong>File/Folder Path</strong>Â is the same order that Harness applies the patches during the kustomization build.</div><div class="note-callout">Small patches that do one thing are recommended. For example, create one patch for increasing the deployment replica number and another patch for setting the memory limit.</div><p>ClickÂ <strong>Submit</strong>. The patch file(s) is added to <strong>Kustomize Patches</strong>.</p><p>When the main kustomization.yaml is deployed, the patch is rendered and its overrides are added to the deployment.yaml that is deployed.</p><h5 id="undefined">How Harness Uses patchesStrategicMerge</h5><p>If theÂ <code>patchesStrategicMerge</code>Â label is missing from the kustomization YAML file, but you have added Kustomize Patches to your Harness Service, Harness will add the Kustomize Patches you added in Harness to theÂ <code>patchesStrategicMerge</code>Â in the kustomization file.</p><p>If you have hardcoded patches inÂ <code>patchesStrategicMerge</code>, but not add these patches to Harness as Kustomize Patches, Harness will ignore them.</p><h4>Using Harness Variables in Patches</h4><div class="note-callout">Currently, this feature is behind the Feature FlagÂ <code>KUSTOMIZE_PATCHES_CG</code>. ContactÂ <a href="mailto:support@harness.io" target="_blank">Harness Support</a>Â to enable the feature.</div><p>Kustomize does not natively support variable substitution but Harness supports variable substitution usingÂ <a href="/article/9dvxcegm90-variables">Harness variable expressions</a>Â in Kustomize patches.</p><p>This allows you to configure any patch YAML labels as Harness variables expressions and replace those values at Pipeline runtime.</p><p>Let&#39;s look at an example.</p><p>Here is the deployment.yaml used by our kustomization:</p><pre>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: example-deploy<br/>  namespace: default<br/>  labels:<br/>    app: example-app<br/>  annotations:<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: example-app<br/>  replicas: 1<br/>  strategy:<br/>    type: RollingUpdate<br/>    rollingUpdate:<br/>      maxSurge: 1<br/>      maxUnavailable: 0<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: example-app<br/>    spec:<br/>      containers:<br/>      - name: example-app<br/>        image: harness/todolist-sample:latest<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 5000</pre><p></p><div class="tip-callout">You cannot use Harness variables in the base manifest or kustomization.yaml. You can only use Harness variables in kustomize patches you add inÂ <strong>Kustomize Patches</strong>.</div><p>You add the patch files that will patch deployment.yaml toÂ <strong>Kustomize Patches</strong>. Only these patch files can use Harness variables.</p><p>We&#39;re going to use variables forÂ <code>replicas</code>Â andÂ <code>image</code>.</p><p>Let&#39;s look at the Harness variables in our Service. Here are two Service <a href="/article/q78p7rpx9u-add-service-level-config-variables">Config Variables</a>:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1642111684954/clean-shot-2022-01-13-at-14-07-57.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>One variable is for theÂ <code>image</code>Â and another for theÂ <code>replicas</code>Â count.</p><p>A patch using these variables will look like this:</p><pre>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/> name: example-deploy<br/> namespace: default<br/>spec:<br/> template :<br/>   spec:<br/>     containers:<br/>       - name: example-app<br/>         image: ${serviceVariable.image}<br/> <br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/> name: example-deploy<br/> namespace: default<br/>spec:<br/> replicas: ${serviceVariable.replica}</pre><p></p><p>Add this patch in the Service <strong>Kustomize Patches</strong>.</p><p>Now, when the Pipeline is run, the values for the two variables are rendered in the patch YAML and then the patch is applied to the deployment.yaml.</p><p>If you look at the Initialize phase of the deployment step (in Rolling, Canary, etc), you can see the variable values rendered in the Deployment manifest.</p><h4>Using Harness Secrets in Patches</h4><p>You can also use <a href="/article/ygyvp998mu-use-encrypted-text-secrets">Harness secrets</a> in patches.</p><p>For example, let&#39;s say we have two secrets, one forÂ <code>image</code>Â and one forÂ <code>app</code>:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1642111957182/clean-shot-2022-01-13-at-14-12-28.png"/></figure><p>The following patch uses these secrets forÂ <code>image</code>Â andÂ <code>app</code>, referencing them using the expressionÂ <code>${secrets.getValue(&#34;[secret name]&#34;)}</code>.</p><pre>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: example-deploy<br/>  namespace: default<br/>spec:<br/>  template :<br/>    spec:<br/>      containers:<br/>        - name: example-app<br/>          image: ${secrets.getValue(&#34;image-example&#34;)}<br/><br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: example-service<br/>  namespace: default<br/>spec:<br/>  selector:<br/>    app: ${secrets.getValue(&#34;app&#34;)}</pre><p></p><p>The secret output in the manifest will be asterisks (*). The secret value is not displayed.</p><h4>Override Patches in Environments</h4><p>You can override the Service settings for <strong>Kustomize Patches</strong> in a Harness Environment using <strong>Service Configuration Overrides</strong>.</p><p>Click <strong>Service Configuration Overrides</strong>.</p><p>In <strong>Service</strong>, select the Service for your kustomization that has <strong>Kustomize Patches</strong> configured.</p><p>In <strong>Override Type</strong>, click <strong>Kustomize Patches</strong>.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1642112180574/clean-shot-2022-01-13-at-14-15-51.png"/></figure><p>In <strong>Store Type</strong>, select <strong>Inline</strong> or <strong>Remote</strong>.</p><p>For <strong>Inline</strong>, enter the patch YAML, and click <strong>Submit</strong>.</p><p>For <strong>Remote</strong>, in <strong>Source Repository</strong>, select your Source Repo Connector. See <a href="/article/ay9hlwbgwa-add-source-repo-providers">Add Source Repo Providers</a>.</p><p>For Commit ID,Â select whether to use the latest branch or a specific commit Id/Git tag.</p><p>In <strong>Branch</strong>/<strong>Commit Id</strong>: enter the branch or commit Id/Git tag.</p><p>In <strong>File/Folder Path:</strong>Â enter the path to the patch file(s) from the root of the repo. The file you add should be the same file listed inÂ <code>patchesStrategicMerge</code>Â of the main kustomize file in your Service.</p><div class="note-callout">You can add multiple files by using <strong>Add Patches</strong> multiple times.</div><div class="note-callout">The order in which you add file paths for patches inÂ <strong>File/Folder Path</strong>Â is the same order that Harness applies the patches during the kustomization build.</div><div class="note-callout">Small patches that do one thing are recommended. For example, create one patch for increasing the deployment replica number and another patch for setting the memory limit.</div><p>ClickÂ <strong>Submit</strong>. The patch file(s) is added to <strong>Service Configuration Overrides</strong>.</p><h3>Option: Overlays and Multibases using Variable Expressions</h3><p>An overlay is a kustomization that depends on another kustomization, creating variants of the common base. In simple terms, overlays change pieces of the base kustomization.yaml. These are commonly used in patches.</p><p>A multibase is a type of overlay where copies of the base use the base but make additions, like adding a namespace.yaml. Basically, you are declaring that the overlays aren&#39;t just changing pieces of the base, but are new bases.</p><p>In both overlays and multibases, the most common example is staging and production variants that use a common base but make changes/additions for their environments. A staging overlay could add a configMap and a production overlay could have a higher replica count and persistent disk.</p><p>To execute a staging overlay you would run the following command selecting the overlay&#39;s root:</p><pre>kubectl apply -f $DEMO_HOME/overlays/staging</pre><p>To deploy each overlay in Harness, you could create a Service for each overlay and configure the <strong>Path to kustomization directory</strong> setting in <strong>Remote Manifests</strong> to point to the overlay root:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1583176053132/image.png"/></figure><p>A better method is to use a single Service for all bases and manually or dynamically identify which base to use at deployment runtime.</p><p>You can accomplish this using Harness Variable Expressions in <strong>Path to kustomization directory</strong></p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1583176070761/image.png"/></figure><p></p><h5>Environment Name Variables</h5><p>Using Environment name variables is the simplest method of using one Service and selecting from multiple bases.</p><p>First, in your repo, create separate folders for each environment&#39;s kustomization.yaml. Here we have folders for <strong>dev</strong>, <strong>production</strong>, and <strong>staging</strong>:</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582589475037/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>The kustomization.yaml file in the root will reference these folders of course:</p><pre>resources:<br/>- dev<br/>- staging<br/>- production</pre><p>We are only concerned with staging and production in this example.</p><p>Next, mirror the repo folder names in Harness Environment names. Here we have two Environments named <strong>production</strong> and <strong>staging</strong> for the corresponding repo folders named <strong>production</strong> and <strong>staging</strong>.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582589395010/image.png"/></figure><p>Next, use the built-in Harness variable expression <code>${env.name}</code> in <strong>Path to kustomization directory</strong> to use the Environment names. The <code>${env.name}</code> expression resolves to the name of the Harness Environment used by a Workflow.</p><p>For example, if you have two Environments named <strong>production</strong> and <strong>staging</strong>, at deployment runtime the <code>${env.name}</code> expression resolves to whichever Environment is used by the Workflow.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582588881870/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>Now, to use the <code>${env.name}</code> expression in <strong>Path to kustomization directory</strong>, and reference the Environments and corresponding folders, you would enter <code>kustomize/multibases/${env.name}</code>.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1583176200352/image.png"/></figure><p>Each time a Workflow runs, it will replace the <code>${env.name}</code> expression with the name of the Environment selected for the Workflow.</p><p>For example, if the Workflow uses the Environment <strong>production</strong>, the <strong>Path to kustomization directory</strong> setting will become <code>kustomize/multibases/production</code>. Now Harness looks in the <strong>production</strong> folder in your repo for the kustomization.yaml file.</p><p>Once you have created a Workflow, you can templatize its Service setting so that you can select the Environment and its corresponding repo folder:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582663979736/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>You can also select the Environment in a Trigger than executes the Workflow:</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582664466503/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p></p><p>For more information, see <a href="/article/xerirloz9a-add-a-trigger-2">Triggers</a> and <a href="/article/revc37vl0f-passing-variable-into-workflows">Passing Variables into Workflows and Pipelines from Triggers</a>.</p><h5>Service Variables</h5><p>You can also use Service variables in <strong>Path to kustomization directory</strong>. This allows you to templatize the <strong>Path to kustomization directory</strong> setting and overwrite it at the Harness Environment level. Let&#39;s look at an example.</p><p>Here is an example of using a Service variable in <strong>Path to kustomization directory</strong>:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1583176347452/image.png"/></figure><p>If you have Service <strong>Config Variables</strong> set up, you will see the variable expressions displayed when you enter <code>$</code>. For details on Service variables, see <a href="/article/eb3kfl8uls-service-configuration">Services</a>.</p><p>Service variables can be overwritten at the Harness Environment level. This allows you to use a variable for the <strong>Path to kustomization directory</strong> setting and then override it for each Harness Environment you use with this Service.</p><p>For example, if you have two Environments, staging and production, you can supply different values in each Environment for <strong>Path to kustomization directory</strong>.</p><p>For details on overriding Service settings, see <a href="/article/ycacqs7tlx-override-harness-kubernetes-service-settings">Override Harness Kubernetes Service Settings</a>.</p><h5>Workflow Variables</h5><p>For Workflow variables, you need to create the variable in the Workflow and then enter the variable name manually in <strong>Path to kustomization directory</strong>, following the format <code>${workflow.variable.variable_name}</code>.</p><p>Here is an example of using a Workflow variable for <strong>Path to kustomization directory</strong>:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1583176437929/image.png"/></figure><p>If you use Workflow variables for <strong>Path to kustomization directory</strong>, you can provide a value for <strong>Path to kustomization directory</strong> when you deploy the Workflow (standalone or as part of a Pipeline).</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582586424096/image.png"/></figure><div class="note-callout">Typically, when you deploy a Workflow, you are prompted to select an artifact for deployment. If a Workflow is deploying a Service that uses a remote <strong>Kustomization Configuration</strong>, you are not prompted to provide an artifact for deployment.</div><p>See <a href="/article/m220i1tnia-workflow-configuration">Workflows</a> and <a href="/article/9dvxcegm90-variables">Kubernetes Workflow Variable Expressions</a>.</p><h3>Option: Use Plugins in Deployments</h3><p>Kustomize offers a plugin framework to generate and/or transform a kubernetes resource as part of a kustomization.</p><p>You can add your plugins to the Harness Delegate(s) and then reference them in the Harness Service you are using for the kustomization.</p><p>When Harness deploys, it will apply the plugin you reference just like you would with the <code>--enable_alpha_plugins</code> parameter. See <a href="https://kubectl.docs.kubernetes.io/guides/extending_kustomize/" target="_blank">Extending Kustomize</a> from Kustomize.</p><h4>Add Plugins to Delegate using a Delegate Profile</h4><p>To add a plugin to a Delegate, you create a Delegate Profile and apply it to the Delegates.</p><ol><li>In Harness, click <strong>Setup</strong>, and click <strong>Harness Delegates</strong>.</li><li>Click <strong>Manage Delegate Profiles</strong>, and then click <strong>Add Delegate Profile</strong>. The Delegate Profile settings appear.</li><li>Enter a name and the script for the plugin and click <strong>Submit</strong>.</li></ol><p>For example, here is a ConfigMap generator plugin script:</p><pre>MY_PLUGIN_DIR=$HOME/K_PLUGINS/kustomize/plugin/myDevOpsTeam/sillyconfigmapgenerator<br/>mkdir -p $MY_PLUGIN_DIR<br/>cat &lt;&lt;&#39;EOF&#39; &gt;$MY_PLUGIN_DIR/SillyConfigMapGenerator<br/>#!/bin/bash<br/># Skip the config file name argument.<br/>shift<br/>today=`date +%F`<br/>echo &#34;<br/>kind: ConfigMap<br/>apiVersion: v1<br/>metadata:<br/>  name: the-map<br/>data:<br/>  today: $today<br/>  altGreeting: &#34;$1&#34;<br/>  enableRisky: &#34;$2&#34;<br/>&#34;<br/>EOF<br/>cat $MY_PLUGIN_DIR/SillyConfigMapGenerator<br/>chmod +x $MY_PLUGIN_DIR/SillyConfigMapGenerator<br/>readlink -f $MY_PLUGIN_DIR/SillyConfigMapGenerator</pre><p>Each plugin is added to its own directory, following this convention:</p><pre>$XDG_CONFIG_HOME/kustomize/plugin<br/>    /${apiVersion}/LOWERCASE(${kind})</pre><p>The default value ofÂ <code>XDG_CONFIG_HOME</code>Â isÂ <code>$HOME/.config</code>. See <a href="https://kubectl.docs.kubernetes.io/guides/extending_kustomize/go_plugins/#placement" target="_blank">Placement</a> from Kustomize.</p><p>In the script example above, you can see that the plugin is added to its own folder following the plugin convention:</p><pre>$HOME/K_PLUGINS/kustomize/plugin/myDevOpsTeam/sillyconfigmapgenerator</pre><p>Note the location of the plugin because you will use that location in the Harness Service to indicate where the plugin is located (described below).</p><div class="note-callout">Plugins can only be applied to Harness Kubernetes Delegates.</div><p>Next, apply the Profile to Kubernetes Delegate(s):</p><ol><li>Click the Profile menu in the Delegate lists and choose your Profile.</li></ol><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582665881519/image.png"/></figure><ol><li style="counter-increment:li 1" start="2">Click <strong>Confirm</strong>.</li></ol><p>Wait a few minutes for the Profile to install the plugin. Next click <strong>View Logs</strong> to see the output of the Profile.</p><p></p><h4>Select Plugin in Service</h4><p>Once the plugin is added to the Delegate(s), you can reference it in the Remote Manifests <strong>Path to Kustomize plugin on Delegate</strong> setting in the Harness Service. You will indicate the same location where your Delegate Profile script installed the plugin:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1583176526837/image.png"/></figure><p>Click <strong>Submit</strong>. Harness is now configured to use the plugin when it deploys using kustomize.</p><p></p><h3>Example 1: Multibase Rolling Deployment</h3><p>For this example, we will deploy the <a href="https://github.com/kubernetes-sigs/kustomize/tree/master/examples/multibases" target="_blank">multibases example for Kustomize</a> in a Rolling Update strategy. You can set up a <a href="/article/ay9hlwbgwa-add-source-repo-providers">Harness Source Repro Provider</a> to connect to that repo.</p><p>We will use Harness Environment names that match the base folder names in the repo.</p><p>In the Harness Service, we will use the <code>${env.name}</code> expression in the <strong>Path to kustomization directory</strong> setting.</p><p>When we deploy, the Workflow will use the name of the Environment in <strong>Path to kustomization directory</strong> and the corresponding repo folder&#39;s kustomization.yaml will be used.</p><p>Here is what the repo looks like:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582672315326/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>Here are the Harness Environments whose names correspond to the dev, stage, and production repo folders:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582672712119/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>Here is the Harness Service <strong>Remote Manifests</strong> settings. The <strong>Path to kustomization directory</strong> setting uses the <code>${env.name}</code> expression that will be replaced with a Harness Environment name at deployment runtime.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1583176601635/image.png"/></figure><p>Next we&#39;ll create a Workflow using the Rolling Deployment strategy. Here we select the Service we set up.</p><p>When you first create the Workflow you cannot set the <strong>Environment</strong> setting as a variable expression. Create the Workflow using any of the Environments, and then edit the Workflow settings and turn the <strong>Environment</strong> and <strong>Infrastructure Definition</strong> settings to variable expressions by clicking their <strong>[T]</strong> icons.</p><p>When you are done, the Workflow settings will look like this:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582673459760/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p></p><p>There is nothing to set up in the Workflow. Harness automatically adds the Rollout Deployment step that performs the Kubernetes Rolling Update.</p><p>In the Workflow, click <strong>Deploy</strong>. In <strong>Start New Deployment</strong>, select the name of the Environment that corresponds to the repo folder containing the base you want to use:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582678843311/image.png"/></figure><p>In this example, we select the <strong>stage</strong> Environment. Once deployment is complete you can see the stage repo folder&#39;s base used and the <code>staging-myapp-pod</code> created:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/zrz7nstjha/1582674470111/image.png"/></figure><p></p><h3 id="review_what_workloads_can_i_deploy">Review: What Workloads Can I Deploy?</h3><p>See <a href="/article/6ujb3c70fh">What Can I Deploy in Kubernetes?</a>.</p><h3>Change the Default Path for the Kustomize Binary</h3><p>The Harness Delegate ships with the 3.5.4 <a href="https://github.com/kubernetes-sigs/kustomize/releases" target="_blank">release</a> of Kustomize.</p><p>If you want to use a different release of Kustomize, add it to a location on the Delegate, update the following Delegate files, and restart the Delegate.</p><p>See <a href="/category/gyd73rp7np-manage-delegates">Manage Harness Delegates</a> for details on each Delegate type.</p><h4>Shell Script Delegate</h4><p>Add <code>kustomizePath: &lt;path&gt;</code> to config-delegate.yml.</p><h4>Kubernetes Delegate</h4><p>Update the <code>value</code> environment variable in harness-delegate.yaml:</p><pre>...<br/>name: KUSTOMIZE_PATH<br/>value: &#34;&lt;path&gt;&#34;<br/>...</pre><p></p><h4>Helm Delegate</h4><p>Add <code>kustomizePath: &#34;&lt;path&gt;&#34;</code> to harness-delegate-values.yaml.</p><pre>kustomizePath: &#34;&lt;path&gt;&#34;</pre><h4>Docker Delegate</h4><p>Set the Kustomize path in the launch-harness-delegate.sh:</p><pre>-e KUSTOMIZE_PATH= &lt;path&gt; \</pre><p></p><h4>ECS Delegate</h4><p>Update the following in ecs-task-spec.json:</p><pre>...<br/>{<br/>  &#34;name&#34;: &#34;KUSTOMIZE_PATH&#34;,<br/>  &#34;value&#34;: &#34;&lt;path&gt;&#34;<br/>}<br/>...</pre><h3>Next Steps</h3><ul><li> <a href="/article/dl0l34ge8l-create-a-kubernetes-rolling-deployment">Create a Kubernetes Rolling Deployment</a></li><li> <a href="/article/2xp0oyubjj-create-a-kubernetes-canary-deployment">Create a Kubernetes Canary Deployment</a></li><li> <a href="/article/ukftzrngr1-create-a-kubernetes-blue-green-deployment">Create a Kubernetes Blue/Green Deployment</a></li></ul><p></p>