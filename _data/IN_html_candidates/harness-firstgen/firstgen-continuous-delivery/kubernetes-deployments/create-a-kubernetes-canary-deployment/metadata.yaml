type: article
article_id: 2xp0oyubjj
user_id: mfr0nxh4be
category_id: n03qfofd5w
author:
  name: Michael Cretzman
  profile_image: https://www.gravatar.com/avatar/2e8616837f4ee92be5d19ffe9b9ccba9?d=mm&s=150
title: Create a Kubernetes Canary Deployment
slug: create-a-kubernetes-canary-deployment
description: Creating a Kubernetes Canary Workflow in Harness.
short_version: Creating a Kubernetes Canary Workflow in Harness.
tags:
- Canary Deployment Step
show_toc: true
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: Article updated
  source: API
  triggered_at: 2021-12-02T20:10:55.887159Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Create a Kubernetes Canary Deployment
  description: Creating a Kubernetes Canary Workflow in Harness.
  short_version: Creating a Kubernetes Canary Workflow in Harness.
  body: '<p>This topic will walk you through creating a Canary Workflow in Harness
    for a Deployment workload.</p><p>In this topic:</p><ul><li><a href="#before_you_begin">Before
    You Begin</a></li><li><a href="#review_what_workloads_can_i_deploy">Review: What
    Workloads Can I Deploy?</a></li><li><a href="#review_manifest_and_canary_phases">Review:
    Manifest and Canary Phases</a></li><li><a href="#step_1_create_the_workflow">Step
    1: Create the Workflow</a></li><li><a href="#step_2_create_the_canary_phase">Step
    2: Create the Canary Phase</a></li><li><a href="#step_3_canary_deployment_step">Step
    3: Canary Deployment Step</a><ul><li><a href="#canary_delete_step">Canary Delete Step</a></li><li><a
    href="#verifications_and_canary_deployments">Verifications and Canary Deployments</a></li></ul></li><li><a
    href="#step_4_create_the_primary_phase_using_rolling_update">Step 4: Create the
    Primary Phase using Rolling Update</a></li><li><a href="#example_canary_workflow_deployment">Example:
    Canary Workflow Deployment</a></li><li><a href="#kubernetes_rollback">Kubernetes
    Rollback</a></li><li><a href="#notes">Notes</a></li><li><a href="#next_steps">Next
    Steps</a></li></ul><h3>Before You Begin</h3><div class="note-callout">While you
    can add multiple phases to a Kubernetes Canary Workflow, you should simply use
    the Canary and Primary Phases generated by Harness when you add the first two
    phases. Kubernetes deployments have built-in controls for rolling out in a controlled
    way. The Canary Phase is a way to test the new build, run your verification, then
    roll out to the Primary Phase.</div><p>A Harness Canary Workflow for Kubernetes
    is a little different than a typical <a href="/article/325x7awntc-deployment-concepts-and-strategies">Canary
    deployment</a>.</p><p>This is a standard Canary deployment:</p><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/2xp0oyubjj/1616697268055/image.png"
    style="max-height:60%;max-width:60%" data-hd-height="60%" data-hd-width="60%"/></figure><p>Harness
    does this a little different:</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/325x7awntc/1616629921936/image.png"
    style="max-height:60%;max-width:60%" data-hd-height="60%" data-hd-width="60%"/></figure><p>In
    a typical Canary deployment, all nodes in a single environment are incrementally
    updated in small phases, with each phase requiring a verification/gate to proceed
    to the next phase.</p><p>This typical method isn&#39;t needed for Kubernetes because
    Kubernetes includes Rolling Update. Rolling Update is a built-in control for rolling
    out in a controlled way. It incrementally updates pod instances with new ones.
    New pods are scheduled on nodes with available resources.</p><p>A Harness Kubernetes
    Canary Workflow uses two phases, a Canary and a Kubernetes Rolling Update:</p><ol><li><strong>Phase
    1:</strong> Harness creates a Canary version of the Kubernetes Deployment object
    defined in your Service <strong>Manifests</strong> section. Once that Deployment
    is verified, the Workflow deletes it by default.<br/>Harness provides a Canary
    Phase as a way to test the new build, run your verification, then rollout to the
    subsequent Rolling Update phase.</li><li><strong>Phase 2:</strong> Run the actual
    deployment using a Kubernetes Rolling Update with the number of pods you specify
    in the Service <strong>Manifests</strong> files (for example, <code>replicas:
    3</code>).</li></ol><p>When you add phases to a Kubernetes Canary Workflow, Harness
    automatically generates the steps for Canary and Primary phases. You simply need
    to configure them.</p><div class="note-callout">If you are new to Kubernetes RollingUpdate
    deployments, see <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/"
    target="_blank">Performing a Rolling Update</a> from Kubernetes. That guide summaries
    Rolling Update and provides an interactive, online tutorial.</div><div class="tip-callout">Although
    it is not covered here, you can also scale your Workloads between the Canary and
    Rolling Update phases if you like. You simply add a new Phase and use the Scale
    step. See <a href="/article/va3trqfy49-scale-kubernetes-pods">Scale Kubernetes
    Pods</a>.</div><h3>Review: What Workloads Can I Deploy?</h3><p>See <a href="/article/6ujb3c70fh">What
    Can I Deploy in Kubernetes?</a>.</p><p></p><h3>Review: Manifest and Canary Phases</h3><p>Harness
    pulls the manifests for each Phase in the Canary Workflow. The Canary Phase fetches
    the manifests, and then when the Primary Phase is initiated the manifests are
    pulled again.</p><p>To ensure that the identical manifest is deployed in both
    the Canary and Primary phases, use the <strong>Specific Commit ID</strong> option
    when selecting manifests. See <a href="/article/yjkkwi56hl-link-resource-files-or-helm-charts-in-git-repos">Link
    Resource Files or Helm Charts in Git Repos</a>.</p><p>If you use the <strong>Latest
    from Branch</strong> option, when Harness fetches the manifest for each phase
    there is the possibility that the manifest could change between fetches for the
    Canary and Primary phases.</p><h3>Step 1: Create the Workflow</h3><p>Create the
    Harness Kubernetes Canary Workflow that will preform the Canary deployment.</p><ol><li>In
    your Application, click <strong>Workflows</strong>.</li><li>Click <strong>Add
    Workflow</strong>.</li><li>In <strong>Name</strong>, enter a name for your Workflow.</li><li>In <strong>Workflow
    Type</strong>, select <strong>Canary Deployment</strong>.</li><li>In <strong>Environment</strong>,
    select the Environment you created for your Kubernetes deployment. You will pick
    Infrastructure Definitions from this Environment when you create Phases in the
    Workflow.</li><li>Click <strong>SUBMIT</strong>. By default, the new Canary Workflow
    does not have any phases pre-configured.</li></ol><h3>Step 2: Create the Canary
    Phase</h3><p>The <strong>Canary Phase</strong> creates a Canary deployment using
    your Service <strong>Manifests</strong> files and the number of pods you specify
    in the Workflow&#39;s <strong>Canary Deployment</strong> step.</p><p>To add the
    Canary Phase, do the following:</p><ol><li>In <strong>Deployment Phases</strong>,
    click <strong>Add Phase</strong>. The <strong>Workflow Phase</strong> dialog appears.<figure><a
    href="https://files.helpdocs.io/kw8ldg1itf/other/1568670285313/image.png"><img
    src="https://files.helpdocs.io/kw8ldg1itf/other/1568670285313/image.png" style="max-height:50%;max-width:50%"
    data-hd-height="50%" data-hd-width="50%"/></a></figure></li><li>In <strong>Service</strong>,
    select the <strong>Service</strong> where you set up your Kubernetes configuration
    files.</li><li>In Infrastructure Definition, select the Infrastructure Definition
    where you want this Workflow Phase to deploy your Kubernetes objects. This is
    the Infrastructure Definition with the Kubernetes cluster and namespace for this
    Phase&#39;s deployment.</li><li>In <strong>Service Variable Overrides</strong>,
    you can add a variable to overwrite any variable in the Service you selected.
    Ensure that the variable names are identical. This is the same process described
    for overwriting variables in  <a href="/article/ycacqs7tlx-override-harness-kubernetes-service-settings">Override
    Harness Kubernetes Service Settings</a>.</li><li>Click <strong>SUBMIT</strong>.
    The new Phase is created.</li></ol><p>You&#39;ll notice the Phase is titled <strong>Canary
    Deployment</strong>. You can change the name of any Phase by editing it and entering
    a new name in the <strong>Name</strong> setting.</p><p>Let&#39;s look at the default
    settings for this first Phase of a Canary Workflow.</p><h3>Step 3: Canary Deployment
    Step</h3><p>Click the Phase 1 step, named <strong>Canary Deployment</strong>.
    The <strong>Canary Deployment</strong> step dialog appears.</p><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/wkvsglxmzy/1580254052511/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>In
    this step, you will define how many pods are deployed for a Canary test of the
    configuration files in your Service <strong>Manifests</strong> section.</p><ol><li>In <strong>Instance
    Unit Type</strong>, click <strong>COUNT</strong> or <strong>PERCENTAGE</strong>.</li><li>In <strong>Instances</strong>,
    enter the number of pods to deploy.</li></ol><ul><li>If you selected <strong>COUNT</strong> in <strong>Instance
    Unit Type</strong>, this is simply the number of pods.</li><li>If you selected <strong>PERCENTAGE</strong>,
    enter a percentage of the pods defined in your Service <strong>Manifests</strong> files
    to deploy. For example, in you have <code>replicas: 4</code> in a manifest in
    Service, and you enter <strong>50</strong> in <strong>Instances</strong>, then
    2 pods are deployed in this Phase step.</li></ul><h4>Delegate Selector</h4><p>If
    your Workflow Infrastructure Definition&#39;s Cloud Provider uses a Delegate Selector
    (supported in Kubernetes Cluster and AWS Cloud Providers), then the Workflow uses
    the selected Delegate for all of its steps.</p><p>In these cases, you should <u>not</u> add
    a Delegate Selector to any step in the Workflow. The Workflow is already using
    a Selector via its Infrastructure Definition&#39;s Cloud Provider.</p><p>If your
    Workflow Infrastructure Definition&#39;s Cloud Provider is not using a Delegate
    Selector, and you want this Workflow step to use a specific Delegate, do the following:</p><p>In <strong>Delegate
    Selector</strong>, select the Selector for the Delegate(s) you want to use. You
    add Selectors to Delegates to ensure that they are used to execute the command.
    For more information, see <a href="https://docs.harness.io/article/c3fvixpgsl-select-delegates-for-specific-tasks-with-selectors">Select
    Delegates for Specific Tasks with Selectors</a>.</p><p>Harness will use Delegates
    matching the Selectors you add.</p><p>If you use one Selector, Harness will use
    any Delegate that has that Selector.</p><p>If you select two Selectors, a Delegate
    must have both Selectors to be selected. That Delegate might also have other Selectors,
    but it must have the two you selected.</p><div class="note-callout">You can use
    expressions for Harness built-in variables or Account Default variables in <strong>Delegate
    Selectors</strong>. When the variable expression is resolved at deployment runtime,
    it must match an existing Delegate Selector.<br/><br/>For example, if you have
    a Delegate Selector <strong>prod</strong> and the Workflow is using an Environment
    also named <strong>prod</strong>, the Delegate Selector can be <code>${env.name}</code>.
    This is very useful when you match Delegate Selectors to Application component
    names, such as Environments, Services, etc. It is also a way to template the Delegate
    Selector setting.</div><h4>Manifest Options</h4><div class="note-callout">Currently,
    this feature is behind the Feature Flag <code>KUBERNETES_EXPORT_MANIFESTS</code>.
    Contact <a href="mailto:support@harness.io" target="_blank">Harness Support</a>
    to enable the feature.</div><h5>Export Manifest</h5><p>If you enable this option,
    Harness does the following at runtime:</p><ul><li>Downloads manifests (if remote).</li><li>Renders
    manifests in logs.</li><li>Performs a dry run unless the <strong>Skip Dry Run</strong>
    option is enabled.</li><li>Export the deployment manifests to the variable <code>${k8sResources.manifests}</code>.</li><li><strong>Does
    not deploy the manifests.</strong> To deploy the manifests, you must add another
    Kubernetes step of the same type (Canary, Rolling, Apply, Stage Deployment) an
    enable the <strong>Inherit Manifest</strong> option to deploy a copy of the exported
    manifests.</li></ul><p>If <strong>Export Manifest</strong> is enabled, the manifests
    are not deployed. You can use the <strong>Inherit Manifest</strong> option in
    a subsequent Kubernetes step to deploy a copy of the exported manifests.</p><p>The
    exported manifests can be written to storage on the Delegate where the step is
    run. For example, you can add a <a href="/article/1fjrjbau7x-capture-shell-script-step-output">Shell
    Script</a> step to echo and write the manifest to a file:</p><pre>echo &#34;${k8sResources.manifests}&#34;
    &gt; /opt/harness-delegate/test/canaryPlan</pre><p></p><div class="note-callout">If
    you use <code>${k8sResources.manifests}</code> in a script ensure that your script
    expects multiline output. You can use <code>cat</code> command to concatenate
    the lines.</div><p></p><p>If you have the 3rd party tool that check compliance,
    it can use the exported manifests.</p><p>To deploy the manifests, a copy of the
    exported manifests can be inherited by the next Kubernetes step (Canary, Rolling,
    Apply, Stage Deployment) using the <strong>Inherit Manifest</strong> option.</p><p>If
    <strong>Export Manifest</strong> is enabled in multiple Kubernetes steps of the
    same type in the same Workflow Phase, the last step overrides the exported manifests.
    This is important because the next Kubernetes step to inherit a copy of the exported
    manifests will only use the exported manifests from last Kubernetes step with
    <strong>Export Manifest</strong> is enabled.</p><h5>Inherit Manifest</h5><p>Enable
    this option to inherit and deploy a copy of the manifests exported from the previous
    Kubernetes step (Canary, Rolling, Apply, Stage Deployment) using the <strong>Export
    Manifest</strong> option.</p><p>The <strong>Inherit Manifest</strong> option will
    only inherit the exported manifest from the last Kubernetes step of the same type
    and in the same Workflow Phase.</p><p>For example, if you enable the <strong>Inherit
    Manifest</strong> option in a <strong>Canary Deployment</strong> step, then it
    will only inherit a copy of the manifests exported from the last <strong>Canary
    Deployment</strong> step with the <strong>Export Manifest</strong> option enabled
    in the same Workflow Phase.</p><h5>Inherit Manifest From Canary To Primary Phase</h5><div
    class="note-callout">Currently, this feature is behind the Feature Flag <code>MANIFEST_INHERIT_FROM_CANARY_TO_PRIMARY_PHASE</code>
    and is only applicable to Kubernetes deployments with Canary Workflow phase. Contact
    <a href="mailto:support@harness.io" target="_blank">Harness Support</a> to enable
    the feature.</div><p>Harness pulls the manifests for each Phase in the Canary
    Workflow. The Canary Phase fetches the manifests, and then when the Primary Phase
    is initiated the manifests are pulled again.</p><p>You can select one of the following
    options for <strong>Commit ID</strong> in the <strong>Remote</strong> <strong>Manifests</strong>
    settings:</p><ul><li><strong>Latest from Branch</strong> - Uses the latest commit
    id for both Canary and Primary Phases.</li><li><strong>Specific Commit ID</strong>
    - Uses the specific commit id for both Canary and Primary Phases.</li></ul><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/2xp0oyubjj/1633693925895/clean-shot-2021-10-07-at-10-38-03-20211007-174000.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure><p>To
    ensure that the identical manifest is deployed in both the Canary and Primary
    phases, the commitId recorded in the Canary Phase is used when selecting manifests
    in the Primary Phase.</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2xp0oyubjj/1633450209706/screenshot-2021-10-05-at-9-38-56-pm.png"
    style="max-height:70%;max-width:70%" data-hd-height="70%" data-hd-width="70%"/></figure><p>To
    inherit manifests from the Canary to the Primary phase, you must select <strong>Manifest
    Format</strong> using Git Repositories. Following are the Manifest Formats that
    use Git Repo:</p><ol><li>Kubernetes Resource Specs in YAML format</li><li>Helm
    Chart from Source Repository</li><li>Kustomization Configuration</li><li>OpenShift
    Template<figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2xp0oyubjj/1633435644400/screenshot-2021-10-05-at-5-32-11-pm.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure></li></ol><div
    class="note-callout"><code>MANIFEST_INHERIT_FROM_CANARY_TO_PRIMARY_PHASE</code>
    and <code>KUBERNETES_EXPORT_MANIFESTS</code> can not be enabled at the same time
    because they are not compatible with each other.</div><h4>Skip Dry Run</h4><p>By
    default, Harness uses the <code>--dry-run</code> flag on the <code>kubectl apply</code>
    command during the <strong>Initialize</strong> step of this command, which prints
    the object that would be sent to the cluster without really sending it. If the
    <strong>Skip Dry Run</strong> option is selected, Harness will not use the <code>--dry-run</code>
    flag.</p><p></p><p>Phase 1 of the Canary Deployment Workflow is complete. Now
    the Workflow needs a Primary Phase to roll out the objects defined in the Service <strong>Manifests</strong> section.</p><h4>Canary
    Delete Step</h4><p>See <a href="/article/78oginrhsh-delete-kubernetes-resources">Delete
    Kubernetes Resources</a>.</p><h4>Verifications and Canary Deployments</h4><p>When
    you add Harness Continuous Verification steps to a Canary Workflow, add them to
    the Canary Phase, not the Primary Phase.</p><p>If the Canary Phase is verified,
    then the Primary Phase will proceed successfully. Adding Continuous Verification
    steps to the Primary Phase defeats the purpose of Canary Workflows, because the
    Canary Phase verifies the new deployment against previous deployments.</p><h4>Do
    Not Use Multiple Canary Deployment Steps</h4><p>Your Phase should only use one
    Canary Deployment step. If you use multiple Canary Deployment steps, the last
    step overrides all previous steps, rendering them useless.</p><p>If you want to
    scale the pods deployed by the Canary Deployment step, use the <a href="/article/va3trqfy49-scale-kubernetes-pods">Scale</a>
    step.</p><h3>Step 4: Create the Primary Phase using Rolling Update</h3><p>The
    Primary Phase runs the actual deployment as a rolling update with the number of
    pods you specify in the Service <strong>Manifests</strong> files (for example, <code>replicas:
    3</code>).</p><p>Similar to application-scaling, during a rolling update of a
    Deployment, the Kubernetes service will load-balance the traffic only to available
    pods (an instance that is available to the users of the application) during the
    update.</p><p>To add the Primary Phase, do the following:</p><ol><li>In your <strong>Workflow</strong>,
    in <strong>Deployment Phases</strong>, under <strong>Canary</strong>, click <strong>Add
    Phase</strong>.<figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550272664585/image.png"><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550272664585/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></a></figure>The <strong>Workflow
    Phase</strong> dialog appears.</li><li>In <strong>Service</strong>, select the
    same <strong>Service</strong> you selected in Phase 1.</li><li>In Infrastructure
    Definition, select the same Infrastructure Definition you selected in Phase 1.</li><li>In <strong>Service
    Variable Overrides</strong>, you can add a variable to overwrite any variable
    in the Service you selected. Ensure that the variable names are identical. This
    is the same process described for overwriting variables in  <a href="/article/ycacqs7tlx-override-harness-kubernetes-service-settings">Override
    Harness Kubernetes Service Settings</a>.</li><li>Click <strong>SUBMIT</strong>.
    The new Phase is created.<figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550272893566/image.png"><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550272893566/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></a></figure></li></ol><p>The
    Phase is named <strong>Primary</strong> automatically, and contains one step, <strong>Rollout
    Deployment</strong>.</p><p><strong>Rollout Deployment</strong> performs a rolling
    update. Rolling updates allow an update of a Deployment to take place with zero
    downtime by incrementally updating pod instances with new ones. The new pods are
    scheduled on nodes with available resources. The rolling update Deployment uses
    the number of pods you specified in the Service <strong>Manifests</strong> (number
    of replicas).</p><h3>Example: Canary Workflow Deployment</h3><p>Let&#39;s look
    at how the Workflow steps deploy the workload.</p><h4 id="canary_deployment_step_in_deployment">Canary
    Deployment Step in Deployment</h4><p>Let&#39;s look at an example where the <strong>Canary
    Deployment</strong> step is configured to deploy a <strong>COUNT</strong> of <strong>2</strong>.
    Here is the step in the Harness <strong>Deployments</strong> page:</p><figure><a
    href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550268937971/image.png"><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550268937971/image.png"/></a></figure><p>You
    can see <strong>Target Instance Count 2</strong> in the Details section.</p><p>Below
    Details you can see the logs for the step.</p><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550269644094/image.png"><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550269644094/image.png"
    style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></a></figure><p>Let&#39;s
    look at the <strong>Prepare</strong>, <strong>Apply</strong>, and <strong>Wait</strong> <strong>for
    Steady State</strong> sections of the step&#39;s deployment log, with comments
    added:</p><h5>Prepare</h5><p>Here is the log from the Prepare section:</p><pre
    class="hljs sql">Manifests processed. Found following resources: <br/><br/># API
    objects in manifest file<br/><br/>Kind                Name                                    Versioned
    <br/>ConfigMap           harness-example-config                  true      <br/>Deployment          harness-example-deployment              false     <br/><br/>#
    each deployment is versioned, this is the second deployment<br/><br/>Current release
    number is: 2 <br/><br/>Versioning resources.<br/><br/># previous deployment<br/><br/>Previous
    Successful Release is 1 <br/><br/>Cleaning up older and failed releases<br/><br/>#
    existing number if pods<br/><br/>Current replica count is 1 <br/><br/># Deployment
    workload executed<br/><br/>Canary Workload is: Deployment/harness-example-deployment-canary
    <br/><br/># number specified in Canary Deployment step Instance field<br/><br/>Target
    replica count for Canary is 2 <br/><br/>Done.</pre><p>The name of the Deployment
    workload in the Service <strong>Manifests</strong> file is <strong>harness-example-deployment</strong> (the
    name variable is <code>harness-example</code>): <strong>.</strong></p><pre class="hljs
    makefile">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: {{.Values.name}}-deployment</pre><p>As
    you can see, Harness appends the name with <strong>-canary</strong>, <strong>harness-example-deployment-canary</strong>.
    This is to identify Canary Deployment step workloads in your cluster.</p><p>The
    next section is <strong>Apply</strong>.</p><h5>Apply</h5><p>Here you will see
    the manifests in the Service <strong>Manifests</strong> section applied using
    kubectl as a single file, <strong>manifests.yaml</strong>.</p><pre class="hljs
    nginx"># kubectl command to apply manifests<br/><br/>kubectl --kubeconfig=config
    apply --filename=manifests.yaml --record<br/><br/># ConfigMap object created<br/><br/>configmap/harness-example-config-2
    created<br/><br/># Deployment object created<br/><br/>deployment.apps/harness-example-deployment-canary
    created<br/><br/>Done.</pre><p>Next, Harness logs the steady state of the pods.</p><h5>Wait
    for Steady State</h5><p>Harness displays the status of each pod deployed and confirms
    steady state.</p><pre class="hljs coffeescript"># kubectl command for get events<br/><br/>kubectl
    --kubeconfig=config get events --output=custom-columns=KIND:involvedObject.kind,NAME:.involvedObject.name,MESSAGE:.message,REASON:.reason
    --watch-only<br/><br/># kubectl command for status<br/><br/>kubectl --kubeconfig=config
    rollout status Deployment/harness-example-deployment-canary --watch=true<br/><br/>#
    status of each pod <br/><br/>Status : Waiting for deployment &#34;harness-example-deployment-canary&#34;
    rollout to finish: 0 of 2 updated replicas are available...<br/>Event  : Pod    harness-example-deployment-canary-8675b5b8bf-98sf6   MountVolume.SetUp
    succeeded for volume &#34;default-token-hwzdf&#34;    SuccessfulMountVolume<br/>Event  :
    Pod   harness-example-deployment-canary-8675b5b8bf-rl2n8   pulling image &#34;registry.hub.docker.com/library/nginx:stable-perl&#34;   Pulling<br/>Event  :
    Pod   harness-example-deployment-canary-8675b5b8bf-98sf6   pulling image &#34;registry.hub.docker.com/library/nginx:stable-perl&#34;   Pulling<br/>Event  :
    Pod   harness-example-deployment-canary-8675b5b8bf-rl2n8   Successfully pulled
    image &#34;registry.hub.docker.com/library/nginx:stable-perl&#34;   Pulled<br/>Event  :
    Pod   harness-example-deployment-canary-8675b5b8bf-98sf6   Successfully pulled
    image &#34;registry.hub.docker.com/library/nginx:stable-perl&#34;   Pulled<br/>Event  :
    Pod   harness-example-deployment-canary-8675b5b8bf-rl2n8   Created container   Created<br/>Event  :
    Pod   harness-example-deployment-canary-8675b5b8bf-98sf6   Created container   Created<br/>Event  :
    Pod   harness-example-deployment-canary-8675b5b8bf-rl2n8   Started container   Started<br/>Event  :
    Pod   harness-example-deployment-canary-8675b5b8bf-98sf6   Started container   Started<br/><br/>Status
    : Waiting for deployment &#34;harness-example-deployment-canary&#34; rollout to
    finish: 1 of 2 updated replicas are available...<br/><br/># canary deployment
    step completed<br/><br/>Status : deployment &#34;harness-example-deployment-canary&#34;
    successfully rolled out<br/><br/>Done.</pre><h5>Wrap Up</h5><p>The Wrap Up log
    is long and describes all of the container and pod information for the step, using
    the kubectl command:</p><pre class="hljs nginx">kubectl --kubeconfig=config describe
    --filename=manifests.yaml</pre><h4 id="primary_step_in_deployment">Primary Step
    in Deployment</h4><p>Let&#39;s look at an example where the <strong>Primary</strong> step
    deploys the Service <strong>Manifests</strong> objects. Here is the step in the
    Harness <strong>Deployments</strong> page:</p><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550273385657/image.png"><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550273385657/image.png"/></a></figure><p>Before
    we look at the logs, let&#39;s look at the Service <strong>Manifests</strong> files
    it&#39;s deploying.</p><p>Here is the values.yaml from our Service <strong>Manifests</strong> section:</p><pre
    class="hljs http">name: harness-example<br/>replicas: 1<br/>image: ${artifact.metadata.image}</pre><p>Here
    is the spec.yaml from our Service <strong>Manifests</strong> section:</p><pre
    class="hljs properties">apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name:
    {{.Values.name}}-config<br/>data:<br/>  key: value<br/>---<br/>apiVersion: apps/v1<br/>kind:
    Deployment<br/>metadata:<br/>  name: {{.Values.name}}-deployment<br/>spec:<br/>  replicas:
    {{int .Values.replicas}}<br/>  selector:<br/>    matchLabels:<br/>      app: {{.Values.name}}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app:
    {{.Values.name}}<br/>    spec:<br/>      containers:<br/>      - name: {{.Values.name}}<br/>        image:
    {{.Values.image}}<br/>        envFrom:<br/>        - configMapRef:<br/>            name:
    {{.Values.name}}-config<br/>        ports:<br/>        - containerPort: 80</pre><p>Let&#39;s
    look at the <strong>Initialize</strong>, <strong>Prepare</strong>, and <strong>Apply</strong> stages
    of the <strong>Rollout Deployment</strong>.</p><h5>Initialize</h5><p>In the <strong>Initialize</strong> section
    of the <strong>Rollout Deployment</strong> step, you can see the same object descriptions
    as the Service <strong>Manifests</strong> section:</p><pre class="hljs properties">Initializing..<br/><br/>Manifests
    [Post template rendering] :<br/><br/># displays the manifests taken from the Service
    Manifests section<br/><br/>---<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name:
    harness-example-config<br/>data:<br/>  key: value<br/>---<br/>apiVersion: apps/v1<br/>kind:
    Deployment<br/>metadata:<br/>  name: harness-example-deployment<br/>spec:<br/>  replicas:
    1<br/>  selector:<br/>    matchLabels:<br/>      app: harness-example<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app:
    harness-example<br/>    spec:<br/>      containers:<br/>      - name: harness-example<br/>        image:
    registry.hub.docker.com/library/nginx:stable-perl<br/>        envFrom:<br/>        -
    configMapRef:<br/>            name: harness-example-config<br/>        ports:<br/>        -
    containerPort: 80<br/><br/># Validates the YAML syntax of the manifest with a
    dry run<br/><br/>Validating manifests with Dry Run<br/><br/>kubectl --kubeconfig=config
    apply --filename=manifests-dry-run.yaml --dry-run<br/>configmap/harness-example-config
    created (dry run)<br/>deployment.apps/harness-example-deployment configured (dry
    run)<br/><br/>Done.<br/></pre><p>Now that Harness has ensured that manifests can
    be used, it will process the manifests.</p><h5>Prepare</h5><p>In the <strong>Prepare</strong> section,
    you can see that Harness versions the ConfigMap and Secret resources (for more
    information, see <a href="/article/ttn8acijrz-versioning-and-annotations">Kubernetes
    Versioning and Annotations</a>).</p><pre class="hljs sql">Manifests processed.
    Found following resources: <br/><br/># determine if the resources are versioned<br/><br/>Kind                Name                                    Versioned
    <br/>ConfigMap           harness-example-config                  true      <br/>Deployment          harness-example-deployment              false     <br/><br/>#
    indicates that these objects have been released before<br/><br/>Current release
    number is: 2<br/><br/>Previous Successful Release is 1<br/><br/># removed unneeded
    releases<br/><br/>Cleaning up older and failed releases<br/><br/># identifies
    new Deployment workload<br/><br/>Managed Workload is: Deployment/harness-example-deployment<br/><br/>#
    versions the new release<br/><br/>Versioning resources.<br/><br/>Done.</pre><p>Now
    Harness can apply the manifests.</p><h5>Apply</h5><p>The Apply section shows the
    kubectl commands for applying your manifests.</p><pre class="hljs nginx"># the
    Service Manifests section are compiled into one file and applied<br/><br/>kubectl
    --kubeconfig=config apply --filename=manifests.yaml --record<br/><br/># the objects
    applied<br/><br/>configmap/harness-example-config-2 configured<br/>deployment.apps/harness-example-deployment
    configured<br/><br/>Done.</pre><p>Now that the manifests are applied, you can
    see the container and pod details described in <strong>Wrap Up</strong>.</p><h5>Wrap
    Up</h5><p>Wrap Up is long and uses a kubectl describe command to provide information
    on all containers and pods deployed:</p><pre class="hljs nginx">kubectl --kubeconfig=config
    describe --filename=manifests.yaml</pre><p>Here is a sample from the output that
    displays the Kubernetes RollingUpdate:</p><pre class="hljs makefile"># Deployment
    name<br/><br/>Name:                   harness-example-deployment<br/><br/># namespace
    from Deployment manifest<br/><br/>Namespace:              default<br/>CreationTimestamp:      Wed,
    13 Feb 2019 01:00:49 +0000<br/>Labels:                 &lt;none&gt;<br/>Annotations:            deployment.kubernetes.io/revision:
    2<br/>                        kubectl.kubernetes.io/last-applied-configuration:<br/>                          {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;kubernetes.io/change-cause&#34;:&#34;kubectl
    apply --kubeconfig=config --f...<br/>                        kubernetes.io/change-cause:
    kubectl apply --kubeconfig=config --filename=manifests.yaml --record=true<br/><br/>#
    Selector applied<br/><br/>Selector:               app=harness-example,harness.io/track=stable<br/><br/>#
    number of replicas from the manifest<br/><br/>Replicas:               1 desired
    | 1 updated | 1 total | 1 available | 0 unavailable<br/><br/># RollingUpdate strategy<br/><br/>StrategyType:           RollingUpdate<br/>MinReadySeconds:        0<br/><br/>#
    RollingUpdate progression<br/><br/>RollingUpdateStrategy:  25% max unavailable,
    25% max surge<br/></pre><p>As you look through the description in <strong>Wrap
    Up</strong> you can see label added:</p><pre class="hljs cs">add label: harness.io/track=stable
    </pre><p></p><p>You can use the <code>harness.io/track=stable</code> label with
    the values <code>canary</code> or <code>stable</code> as a selector for managing
    traffic to these pods, or for testing the pods. For more information, see <a href="/article/ttn8acijrz-versioning-and-annotations">Kubernetes
    Versioning and Annotations</a>.</p><p>The Workflow is deployed.</p><p>Now that
    you have successfully deployed your artifact to your Kubernetes cluster pods using
    your Harness Application, look at the completed workload in the deployment environment
    of your Kubernetes cluster.</p><p>For example, here is the Deployment workload
    in Google Cloud Kubernetes Engine:</p><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550276136165/image.png"><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/zmca0zai3s/1550276136165/image.png"/></a></figure><p>Or
    you can simply connect to your cluster in a terminal and see the pod(s) deployed:</p><pre
    class="hljs ruby">john_doe@cloudshell:~ (project-15454)$ kubectl get pods<br/>NAME                                                        READY     STATUS    RESTARTS   AGE<br/>harness-example-deployment-7df7559456-xdwg5                 1/1       Running   0          9h</pre><p
    id="blue_green_workflows_and_deployments"></p><h3>Kubernetes Rollback</h3><p>See
    <a href="/article/v41e8oo00e-kubernetes-rollback">Kubernetes Rollback</a>.</p><h3>Notes</h3><ul><li>If
    you are using the <strong>Traffic Split</strong> step or doing Istio traffic shifting
    using the <strong>Apply step</strong>, move the <strong>Canary Delete</strong>
    step from <strong>Wrap Up</strong> section of the <strong>Canary</strong> phase
    to the <strong>Wrap Up</strong> section of the Primary phase.<br/>Moving the Canary
    Delete step to the Wrap Up section of the Primary phase will prevent any traffic
    from being routed to deleted pods before traffic is routed to stable pods in the
    Primary phase.<br/>For more information, see <a href="/article/1qfb4gh9e8-set-up-kubernetes-traffic-splitting">Set
    Up Kubernetes Traffic Splitting</a>, <a href="/article/78oginrhsh-delete-kubernetes-resources">Delete
    Kubernetes Resources</a>, and <a href="/article/4vjgmjcj6z-deploy-manifests-separately-using-apply-step">Deploy
    Manifests Separately using Apply Step</a>.</li><li>Harness does not roll back
    Canary deployments because your production is not affected during Canary. Canary
    catches issues before moving to production. Also, you might want to analyze the
    Canary deployment. The Canary Delete step is useful to perform cleanup when required.</li><li><strong>Instances
    Deployed</strong> — In the <strong>Deployments</strong> page, the <strong>Instances
    Deployed</strong> label shows the total number of pods deployed in the entire
    deployment, including the Canary and Rollout steps.</li></ul><h3>Next Steps</h3><ul><li><a
    href="/article/ukftzrngr1-create-a-kubernetes-blue-green-deployment">Create a
    Kubernetes Blue/Green Deployment</a></li><li><a href="/article/1qfb4gh9e8-set-up-kubernetes-traffic-splitting">Set
    Up Kubernetes Traffic Splitting</a></li><li><a href="/article/78oginrhsh-delete-kubernetes-resources">Delete
    Kubernetes Resources</a></li><li><a href="/article/4vjgmjcj6z-deploy-manifests-separately-using-apply-step">Deploy
    Manifests Separately using Apply Step</a></li><li><a href="/article/tkubd954r6-traffic-splitting-without-istio">Traffic
    Splitting Without Istio</a></li></ul><p></p>'
  slug: create-a-kubernetes-canary-deployment
  tags:
  - Canary Deployment Step
  is_live: true
