type: article
article_id: 4vjgmjcj6z
user_id: mfr0nxh4be
category_id: n03qfofd5w
author:
  name: Michael Cretzman
  profile_image: https://www.gravatar.com/avatar/2e8616837f4ee92be5d19ffe9b9ccba9?d=mm&s=150
title: Deploying Manifests Separately using Apply Step
slug: deploy-manifests-separately-using-apply-step
description: Deploy manifests separately.
short_version: Deploy manifests separately.
tags:
- apply command
- skip-file-for-deploy
show_toc: true
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: Article updated
  source: API
  triggered_at: 2022-08-31T21:28:43.991858Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Deploying Manifests Separately using Apply Step
  description: Deploy manifests separately.
  short_version: Deploy manifests separately.
  body: '<p>By default, the Harness Kubernetes Workflow will deploy all of the resources
    you have set up in the Service <strong>Manifests</strong> section.</p><div class="note-callout">Deploying
    Kubernetes Jobs? See <a href="/article/qpv2jfdjgm-run-kubernetes-jobs">Run Kubernetes
    Jobs</a>.</div><p>In some cases, you might have resources that you do not want
    to deploy as part of the main Workflow deployment, but want to apply as another
    step in the Workflow. For example, you might want to deploy an additional resource
    only after Harness has verified the deployment of the main resources in the Service <strong>Manifests</strong> section.</p><p>Workflows
    include an <strong>Apply</strong> step that allows you to deploy any resource
    you have set up in the Service <strong>Manifests</strong> section.</p><h3>Before
    You Begin</h3><ul><li><a href="/article/vv25jkq4d7-ignore-a-manifest-file-during-deployment">Ignore
    a Manifest File During Deployment</a></li><li><a href="/article/2j2vi5oxrq-define-kubernetes-manifests">Define
    Kubernetes Manifests</a></li><li><a href="/article/ttn8acijrz-versioning-and-annotations">Kubernetes
    Versioning and Annotations</a></li></ul><h3>Review: What Workloads Can I Deploy?</h3><p>See
    <a href="/article/6ujb3c70fh">What Can I Deploy in Kubernetes?</a>.</p><h3>Step
    1: Ignore the Workload</h3><p>Typically, you will instruct Harness to ignore the
    workload that you want to deploy separately using the <strong>Apply Step</strong>.</p><p>To
    have a Workflow ignore a resource file in a Service Manifest section, you add
    the comment <code># harness.io/skip-file-for-deploy</code> to the <strong>top</strong> of
    the file. For example, here is a ConfigMap file using the comment:</p><p></p><figure><img
    src="https://files.helpdocs.io/i5nl071jo5/articles/00el61pzok/1580859475944/image.png"
    style="max-height:50%;max-width:50%;display:block;margin-left:auto;margin-right:auto"
    data-hd-height="50%" data-hd-width="50%" data-hd-align="center"/></figure><p>Now,
    when this Service is deployed by a Workflow, this ConfigMap resource will not
    be applied by default.</p><div class="note-callout">The comment <code># harness.io/skip-file-for-deploy</code> must
    be at the <strong>top</strong> of the file. If it is on the second line it will
    not work and the resource will be deployed as part of the main Workflow rollout.</div><h3>Step
    2: Add the Apply Step</h3><p>In your Kubernetes Workflow, click <strong>Add Step</strong>,
    and then select <strong>Apply</strong>.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/4vjgmjcj6z/1619459232548/image.png"/></figure><h3>Step
    3: Enter the Path and Name of the Manifest</h3><p>The Workflow Apply step will
    apply any resource in a Service <strong>Manifest</strong> section explicitly.
    You must provide the path and name of the file in <strong>Apply</strong>, and
    Harness will deploy the resource.</p><p>For example, the following image shows
    a Jobs resource in a Service <strong>Manifest</strong> section that uses the ignore
    comment <code># harness.io/skip-file-for-deploy</code> so that the Workflow does
    not apply it as part of its main <strong>Deploy</strong> steps, and the <strong>Apply</strong> step
    that specifies the same Jobs resource:</p><figure><a href="https://files.helpdocs.io/kw8ldg1itf/articles/crzdm3458j/1580256082187/image.png"><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/crzdm3458j/1580256082187/image.png"/></a></figure><p>The <strong>File
    paths</strong> field in the Apply step must include the folder name and the file
    name. In the above example, the folder <strong>templates</strong> is included
    with the file name <strong>jobs.yaml</strong>: <code>templates/jobs.yaml</code>.</p><p>You
    can include multiple resource files in the Apply step <strong>File paths</strong> field
    by separating them with commas, for example: <code>templates/jobs.yaml, templates/statefulSet.yaml</code>:</p><p></p><figure><img
    src="https://files.helpdocs.io/kw8ldg1itf/articles/4vjgmjcj6z/1619460094014/image.png"/></figure><div
    class="note-callout">If you apply the ignore comment <code># harness.io/skip-file-for-deploy</code> to
    a resource but do not use the resource in an Apply step, the resource is never
    deployed.</div><p>If you use a remote manifest in your Harness Service, in <strong>File
    paths</strong> enter a path relative to the path you specified for the manifest
    in the Harness Service.</p><div class="note-callout">Harness variables such as
    <a href="/article/766iheu1bk-add-workflow-variables-new-template">Workflow variables</a>
    are supported in the <strong>File Paths</strong> setting.</div><p></p><h3>Option:
    Manifest Options</h3><div class="note-callout">Currently, this feature is behind
    the Feature Flag <code>KUBERNETES_EXPORT_MANIFESTS</code>. Contact <a href="mailto:support@harness.io"
    target="_blank">Harness Support</a> to enable the feature.</div><h4>Export Manifest</h4><p>If
    you enable this option, Harness does the following at runtime:</p><ul><li>Downloads
    manifests (if remote).</li><li>Renders manifests in logs.</li><li>Performs a dry
    run unless the <strong>Skip Dry Run</strong> option is enabled.</li><li>Export
    the deployment manifests to the variable <code>${k8sResources.manifests}</code>.</li><li><strong>Does
    not deploy the manifests.</strong> To deploy the manifests, you must add another
    Kubernetes step of the same type (Canary, Rolling, Apply, Stage Deployment) an
    enable the <strong>Inherit Manifest</strong> option to deploy a copy of the exported
    manifests.</li></ul><p>If <strong>Export Manifest</strong> is enabled, the manifests
    are not deployed. You can use the <strong>Inherit Manifest</strong> option in
    a subsequent Kubernetes step to deploy a copy of the exported manifests.</p><p>The
    exported manifests can be written to storage on the Delegate where the step is
    run. For example, you can add a <a href="/article/1fjrjbau7x-capture-shell-script-step-output">Shell
    Script</a> step to echo and write the manifest to a file:</p><pre>echo &#34;${k8sResources.manifests}&#34;
    &gt; /opt/harness-delegate/test/canaryPlan</pre><p></p><div class="note-callout">If
    you use <code>${k8sResources.manifests}</code> in a script ensure that your script
    expects multiline output. You can use <code>cat</code> command to concatenate
    the lines.</div><p>If you have the 3rd party tool that check compliance, it can
    use the exported manifests.</p><p>To deploy the manifests, a copy of the exported
    manifests can be inherited by the next Kubernetes step (Canary, Rolling, Apply,
    Stage Deployment) using the <strong>Inherit Manifest</strong> option.</p><p>If
    <strong>Export Manifest</strong> is enabled in multiple Kubernetes steps of the
    same type in the same Workflow Phase, the last step overrides the exported manifests.
    This is important because the next Kubernetes step to inherit a copy of the exported
    manifests will only use the exported manifests from last Kubernetes step with
    <strong>Export Manifest</strong> is enabled.</p><h4>Inherit Manifest</h4><p>Enable
    this option to inherit and deploy a copy of the manifests exported from the previous
    Kubernetes step (Canary, Rolling, Apply, Stage Deployment) using the <strong>Export
    Manifest</strong> option.</p><p>The <strong>Inherit Manifest</strong> option will
    only inherit the exported manifest from the last Kubernetes step of the same type
    and in the same Workflow Phase.</p><p>For example, if you enable the <strong>Inherit
    Manifest</strong> option in a <strong>Canary Deployment</strong> step, then it
    will only inherit a copy of the manifests exported from the last <strong>Canary
    Deployment</strong> step with the <strong>Export Manifest</strong> option enabled
    in the same Workflow Phase.</p><h3>Option: Delegate Selector</h3><p>If your Workflow
    Infrastructure Definition&#39;s Cloud Provider uses a Delegate Selector (supported
    in Kubernetes Cluster and AWS Cloud Providers), then the Workflow uses the selected
    Delegate for all of its steps.</p><p>In these cases, you shouldn&#39;t add a Delegate
    Selector to any step in the Workflow. The Workflow is already using a Selector
    via its Infrastructure Definition&#39;s Cloud Provider.</p><p>If your Workflow
    Infrastructure Definition&#39;s Cloud Provider isn&#39;t using a Delegate Selector,
    and you want this Workflow step to use a specific Delegate, do the following:</p><p>In <strong>Delegate
    Selector</strong>, select the Selector for the Delegate(s) you want to use. You
    add Selectors to Delegates to make sure that they&#39;re used to execute the command.
    For more information, see <a href="/article/c3fvixpgsl-select-delegates-for-specific-tasks-with-selectors">Select
    Delegates with Selectors</a>.</p><p>Harness will use Delegates matching the Selectors
    you add.</p><p>If you use one Selector, Harness will use any Delegate that has
    that Selector.</p><p>If you select two Selectors, a Delegate must have both Selectors
    to be selected. That Delegate might also have other Selectors, but it must have
    the two you selected.</p><div class="note-callout">You can use expressions for
    Harness built-in variables or Account Default variables in <strong>Delegate Selectors</strong>.
    When the variable expression is resolved at deployment runtime, it must match
    an existing Delegate Selector.<br/><br/>For example, if you have a Delegate Selector <strong>prod</strong> and
    the Workflow is using an Environment also named <strong>prod</strong>, the Delegate
    Selector can be <code>${env.name}</code>. This is very useful when you match Delegate
    Selectors to Application component names such as Environments, Services, etc.
    It&#39;s also a way to template the Delegate Selector setting.</div><p></p><h3
    id="skip_dry_run">Option: Skip Dry Run</h3><p>By default, Harness uses the <code>--dry-run</code> flag
    on the <code>kubectl apply</code> command, which prints the object that would
    be sent to the cluster without really sending it. If the <strong>Skip Dry Run</strong> option
    is selected, Harness will not use the <code>--dry-run</code> flag.</p><h3>Option:
    Skip Steady State Check</h3><p>If you select this, Harness will not check to see
    if the workload has reached steady state.</p><h3>Option: Skip Rendering of Manifest
    Files</h3><p>By default, Harness uses Go templating and a values.yaml for templating
    manifest files. See <a href="/article/mwy6zgz8gu-use-go-templating-in-kubernetes-manifests">Use
    Go Templating in Kubernetes Manifests</a>.</p><p>In some cases, you might not
    want to use Go templating because your manifests use some other formatting.</p><p>Use
    the <strong>Skip Rendering K8s manifest files</strong> option if you want Harness
    to skip rendering your manifest files using Go templating.</p><h3>Option: Override
    YAML Values</h3><p>You can override values in the Values YAML file you are using
    with this <strong>Apply</strong> step.</p><p>For example, if the Apply step is
    deploying a Kubernetes Job by referencing the jobs.yaml in the Harness Service
    used by this Workflow, you can override values in the values.yaml used in the
    Service.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/4vjgmjcj6z/1646676472273/clean-shot-2022-03-07-at-10-05-34.png"/></figure><p>By
    adding or overriding values in the values.yaml, you can pass parameters into the
    Job being deployed.</p><p>Another example is traffic splitting. Let&#39;s say
    your Ingress object uses a values.yaml for the <code>canary-weight</code> annotation
    value. Here you can see the values.yaml <code>canaryWeight</code> values referenced:</p><pre>nginx.ingress.kubernetes.io/canary-weight:
    {{ .Values.canaryWeight }}</pre><p></p><p>In the Apply step, you simply need to
    override this value to set the weight. For example:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/4vjgmjcj6z/1646677136149/clean-shot-2022-03-07-at-10-18-46.png"/></figure><p>You
    can override values.yaml values using inline or remote values.</p><h4>Inline Override</h4><p>Enable
    <strong>Override YAML Values</strong>, and then click <strong>Inline</strong>.</p><p>In
    <strong>Values YAML</strong>, enter the YAML label and value you want to use.
    For example:</p><pre class="hljs yaml">replicas: 2</pre><p></p><p>You can use
    <a href="/article/766iheu1bk-add-workflow-variables-new-template">Workflow variables</a>
    in the value. For example:</p><pre class="hljs yaml">replicas: ${workflow.variables.replicas}</pre><h4>Remote
    Override</h4><p>Enable <strong>Override YAML Values</strong>, and then click <strong>Remote</strong>.</p><p>In
    <strong>Git Connector</strong>, select the Harness Git Connector that connects
    Harness with your Git provider. See <a href="/article/ay9hlwbgwa-add-source-repo-providers">Add
    Source Repo Providers</a>.</p><p>In <strong>Repo Name</strong>, enter the name
    of the repo in your Git account.</p><p>Select a branch or commit Id.</p><p>In
    <strong>Branch Name</strong>, enter the repo branch to use. In <strong>Commit
    ID</strong>, enter the commit Id to use.</p><p>In <strong>File Path</strong>,
    enter the path to the values file that contains the values you want to use.</p><p>Here&#39;s
    an example:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/4vjgmjcj6z/1646678035185/clean-shot-2022-03-07-at-10-33-35.png"/></figure><p>You
    can use <a href="/article/766iheu1bk-add-workflow-variables-new-template">Workflow
    variables</a> in the value. For example:</p><pre class="hljs yaml">replicas: ${workflow.variables.replicas}</pre><h3
    id="apply_step_examples">Apply Step Examples</h3><div class="note-callout">The
    Apply Step is primarily used for deploying Jobs controllers, but it can be used
    for other resources. Typically, when you want to deploy multiple workloads (Deployment,
    StatefulSet, and DaemonSet) you will use separate Workflows for each.</div><p>Deploying
    a resource out of sync with the main resource deployment in a Workflow can be
    useful if a specific resource requires some external service processing that is
    orchestrated around your main rollout, such as database migration.</p><p>One reason
    why a Job controller object is a good use of the Apply step is that represents
    a finite task that runs to completion rather than managing an ongoing desired
    state. You can run a Job to do perform work outside of the primary object deployment,
    such as large computation and batch-oriented tasks.</p><p>In another example,
    let&#39;s say you have two services, serviceA calls serviceB to populate a product
    page. The main Workflow rollout deploys serviceB successfully and then the Apply
    step deploys serviceA next, ensuring serviceA only calls serviceB after serviceB
    is deployed successfully.</p><p>Another example of the use of the Apply step is
    service mesh traffic shifting. Your main Workflow rollout can deploy your services
    and then an Apply step can apply the resource that modifies the service mesh for
    the deployed services (for example, in an Istio-enabled cluster, <code>VirtualService</code>).</p><h3>Notes</h3><ul><li>The <strong>Apply</strong> step
    applies to Service Manifests that are local or added remotely using the <strong>Kubernetes
    Resource Specs in YAML format</strong> option. See <a href="/article/yjkkwi56hl-link-resource-files-or-helm-charts-in-git-repos">Link
    Resource Files or Helm Charts in Git Repos</a>.</li><li>The Apply step does not
    version ConfigMap and Secret objects. ConfigMap and Secret objects are overwritten
    on each deployment. This is the same as when ConfigMap and Secret objects are
    marked as unversioned in typical rollouts (<code>harness.io/skip-versioning: &#34;true&#34;</code>).
    See <a href="/article/ttn8acijrz-versioning-and-annotations">Kubernetes Versioning
    and Annotations</a>.</li><li>You can use Harness variables in your manifests and
    values.yaml files. For example, Harness <a href="/article/766iheu1bk-add-workflow-variables-new-template">Workflow
    variables</a>.</li><li>In some cases, you might want to deploy a Service but skip
    its versioning. By default, release history is stored in the Kubernetes cluster
    in a ConfigMap. This ConfigMap is essential for release tracking, versioning,
    and rollback. If you want Harness to skip versioning for the Service, use the
    <strong>Skip Versioning for Service</strong> option in <strong>Remote Manifests</strong>.
    See <a href="/article/yjkkwi56hl-link-resource-files-or-helm-charts-in-git-repos#option_skip_versioning_for_service">Option:
    Skip Versioning for Service</a>.</li></ul><h3>Next Steps</h3><ul><li><a href="/article/78oginrhsh-delete-kubernetes-resources">Delete
    Kubernetes Resources</a></li><li><a href="/article/vv25jkq4d7-ignore-a-manifest-file-during-deployment">Ignore
    a Manifest File During Deployment</a></li></ul><p></p>'
  slug: deploy-manifests-separately-using-apply-step
  tags:
  - apply command
  - skip-file-for-deploy
  is_live: true
