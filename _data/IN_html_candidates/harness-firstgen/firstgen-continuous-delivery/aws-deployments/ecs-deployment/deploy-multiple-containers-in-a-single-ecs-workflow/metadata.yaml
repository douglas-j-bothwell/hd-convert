type: article
article_id: 2eyw6epug0
user_id: mfr0nxh4be
category_id: df9vj316ec
author:
  name: Michael Cretzman
  profile_image: https://www.gravatar.com/avatar/2e8616837f4ee92be5d19ffe9b9ccba9?d=mm&s=150
title: Deploy Multiple ECS Sidecar Containers
slug: deploy-multiple-containers-in-a-single-ecs-workflow
description: Deploy multiple containers and images using a single Harness ECS Service
  and Workflow.
short_version: Deploy multiple containers and images using a single Harness ECS Service
  and Workflow.
tags: []
show_toc: true
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: Article updated
  source: API
  triggered_at: 2021-05-12T17:21:33.19871Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Deploy Multiple ECS Sidecar Containers
  description: Deploy multiple containers and images using a single Harness ECS Service
    and Workflow.
  short_version: Deploy multiple containers and images using a single Harness ECS
    Service and Workflow.
  body: |-
    <p>You can deploy sidecar containers using a single Harness ECS Service and Workflow.</p><p>In the Harness Service for ECS, in addition to the spec for the Main Container used by Harness, you simply add container specs for however many sidecar containers you need.</p><p>Harness deploys all containers and images as defined in the specs.</p><p>In this topic:</p><ul><li> <a href="#before_you_begin">Before You Begin</a></li><li> <a href="#review_ecs_sidecar_containers">Review: ECS Sidecar Containers</a></li><li> <a href="#review_new_arn_and_resource_id_format_must_be_enabled">Review: New ARN and Resource ID Format Must be Enabled</a></li><li> <a href="#review_main_container_for_ecs_deployments">Review: Main Container for ECS Deployments</a></li><li> <a href="#step_1_add_sidecar_container_specs">Step 1: Add Sidecar Container Specs</a></li><li> <a href="#step_2_identify_main_container_by_tag_in_ecs_console">Step 2: Identify Main Container by Tag in ECS Console</a></li><li> <a href="#option_using_workflow_variables_in_container_specs">Option: Using Workflow Variables in Container Specs</a></li><li> <a href="#notes">Notes</a></li><li> <a href="#next_steps">Next Steps</a></li></ul><h3>Before You Begin</h3><p>This topic assumes you have read or performed the following:</p><ul><li> <a href="/article/j39azkrevm-aws-ecs-deployments">AWS ECS Quickstart</a></li><li> <a href="/article/5z2kw34d7x-aws-ecs-deployments-overview">AWS ECS Deployments Overview</a></li><li> <a href="/article/oinivtywnl-ecs-workflows">ECS Workflows</a></li><li> <a href="/article/7qtpb12dv1-ecs-blue-green-workflows">ECS Blue/Green Workflows</a></li><li>AWS ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definitions" target="_blank">container task definition parameters</a> (from AWS).</li></ul><p></p><h3>Review: ECS Sidecar Containers</h3><p>AWS ECS sidecar containers are common. They move some of the responsibility of a service out into a containerized module deployed alongside a core application container.</p><p>Put simply, they improve performance by freeing your application container from various CPU intensive tasks.</p><p>For example, a telemetry sidecar container that must start before and shut down after the other containers in a task, or an initialization container that must complete its work before other containers in the task can start.</p><p>Here is a blog post from AWS explaining another sidecar use: <a href="https://aws.amazon.com/blogs/compute/nginx-reverse-proxy-sidecar-container-on-amazon-ecs/" target="_blank">Deploying an NGINX Reverse Proxy Sidecar Container on Amazon ECS</a>.</p><h3>Review: New ARN and Resource ID Format Must be Enabled</h3><p>When deploying sidecar containers, Harness uses an AWS tag to distinguish the Main Container. The Main Container is the container used by Harness for the image Harness deploys. Sidecar containers are used for additional images.</p><p>AWS ECS requires that their new ARN and resource ID format be enabled to add tags to the ECS service.</p><p>If you have not opted into the new ECS ARN and resource ID format before you attempt deployment, you might receive the following deployment error:</p><p><code>InvalidParameterException: The new ARN and resource ID format must be enabled to add tags to the service. Opt in to the new format and try again.</code></p><p>To solve this issue, opt into the new format and try again. For more information, see  <a href="https://aws.amazon.com/blogs/compute/migrating-your-amazon-ecs-deployment-to-the-new-arn-and-resource-id-format-2/" target="_blank">Migrating your Amazon ECS deployment to the new ARN and resource ID format</a> from AWS.</p><h3>Review: Main Container for ECS Deployments</h3><p>The Main Container is the container used by Harness for deployments. Its spec is defined in the Harness Service.</p><p>You can add sidecar containers, as described in this topic, but you must always include the Main Container.</p><p>The Main Container is identified using the following mandatory placeholders:</p><ul><li><code>${CONTAINER_NAME}</code> — At deployment runtime, this placeholder is replaced with a container name based on the image name. Such as <code>harness_todolist-sample_9</code>. Each time you deploy the container, its numeric suffix is increased (<code>_9</code>).</li><li><code>${DOCKER_IMAGE_NAME}</code> — At deployment runtime, this placeholder is replaced with the Docker image name and tag. Such as <code>harness/todolist-sample:9</code>.  </li></ul><div class="warning-callout">The Main Container task spec must have a container definition using the placeholders.</div><h3>Step 1: Add Sidecar Container Specs</h3><p>ECS container specs are added in Harness Services. The <strong>Deployment Type</strong> for the Services must be <strong>Amazon ECS Container Service (ECS)</strong>:</p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587160091963/image.png"/></figure><p></p><ol><li>In the Harness ECS Service, in <strong>Deployment Specification</strong>, click <strong>Container Specification</strong>. The <strong>ECS - Container Command Definition</strong> settings appear.<figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587160147044/image.png" style="max-height:50%;max-width:50%" data-hd-height="50%" data-hd-width="50%"/></figure>The simple interface is for adding a single, EC2 container spec. For Fargate, sidecar containers, or granular settings, use <strong>Advanced Settings</strong>.</li><li>Click <strong>Advanced Settings</strong>.</li></ol><p>Here is where you will enter the sidecar container task definitions.</p><p>The first definition is for the Main Container, and uses the Harness placeholders for container name and image:</p><pre>{<br/>  &#34;containerDefinitions&#34; : [ {<br/>    &#34;name&#34; : &#34;${CONTAINER_NAME}&#34;,<br/>    &#34;image&#34; : &#34;${DOCKER_IMAGE_NAME}&#34;,<br/>    &#34;cpu&#34; : 1,<br/>    &#34;memory&#34; : 1000,<br/>...</pre><p>Now let&#39;s add a second container spec for a sidecar container.</p><p>For this example, we&#39;ll simply copy the default container spec but use the suffix <code>_Sidecar</code> for the side container name.</p><pre>...<br/>{<br/>    &#34;name&#34; : &#34;${CONTAINER_NAME}_Sidecar&#34;,<br/>    &#34;image&#34; : &#34;${DOCKER_IMAGE_NAME}&#34;,<br/>    &#34;memory&#34; : &#34;512&#34;,<br/>    &#34;portMappings&#34; : [ {<br/>      &#34;containerPort&#34; : 85,<br/>      &#34;protocol&#34; : &#34;tcp&#34;<br/>    } ]<br/>  } ],<br/>...</pre><p></p><p></p><div class="hd--md" data-hd-markdown="&lt;details&gt;
      &lt;summary style=&#34;font-size: 1.25rem;outline: none;border: none; color: #00adea; margin-bottom:20px&#34;&gt;Here is what the full specs look like:&lt;/summary&gt;

    &lt;pre&gt;
    {
      &#34;containerDefinitions&#34; : [ {
        &#34;name&#34; : &#34;${CONTAINER_NAME}&#34;,
        &#34;image&#34; : &#34;${DOCKER_IMAGE_NAME}&#34;,
        &#34;links&#34; : [ ],
        &#34;portMappings&#34; : [ {
          &#34;containerPort&#34; : 80,
          &#34;protocol&#34; : &#34;tcp&#34;
        } ],
        &#34;memory&#34; : &#34;512&#34;,
        &#34;entryPoint&#34; : [ ],
        &#34;command&#34; : [ ],
        &#34;environment&#34; : [ ],
        &#34;mountPoints&#34; : [ ],
        &#34;volumesFrom&#34; : [ ],
        &#34;dependsOn&#34; : [ ],
        &#34;dnsServers&#34; : [ ],
        &#34;dnsSearchDomains&#34; : [ ],
        &#34;extraHosts&#34; : [ ],
        &#34;dockerSecurityOptions&#34; : [ ],
        &#34;ulimits&#34; : [ ],
        &#34;systemControls&#34; : [ ],
        &#34;resourceRequirements&#34; : [ ]
      },
    {
        &#34;name&#34; : &#34;${CONTAINER_NAME}_Sidecar&#34;,
        &#34;image&#34; : &#34;${DOCKER_IMAGE_NAME}&#34;,
        &#34;memory&#34; : &#34;512&#34;,
        &#34;portMappings&#34; : [ {
          &#34;containerPort&#34; : 85,
          &#34;protocol&#34; : &#34;tcp&#34;
        } ]
      } ],
      &#34;executionRoleArn&#34; : &#34;${EXECUTION_ROLE}&#34;,
      &#34;volumes&#34; : [ ],
      &#34;requiresAttributes&#34; : [ ],
      &#34;placementConstraints&#34; : [ ],
      &#34;compatibilities&#34; : [ ],
      &#34;requiresCompatibilities&#34; : [ ],
      &#34;cpu&#34; : &#34;512&#34;,
      &#34;memory&#34; : &#34;1024&#34;,
      &#34;inferenceAccelerators&#34; : [ ]
    }
    &lt;/pre&gt;
    &lt;/details&gt;"><details>
      <summary style="font-size: 1.25rem;outline: none;border: none; color: #00adea; margin-bottom:20px">Here is what the full specs look like:</summary>
    <pre><br/>
    {<br/>
      &#34;containerDefinitions&#34; : [ {<br/>
        &#34;name&#34; : &#34;${CONTAINER_NAME}&#34;,<br/>
        &#34;image&#34; : &#34;${DOCKER_IMAGE_NAME}&#34;,<br/>
        &#34;links&#34; : [ ],<br/>
        &#34;portMappings&#34; : [ {<br/>
          &#34;containerPort&#34; : 80,<br/>
          &#34;protocol&#34; : &#34;tcp&#34;<br/>
        } ],<br/>
        &#34;memory&#34; : &#34;512&#34;,<br/>
        &#34;entryPoint&#34; : [ ],<br/>
        &#34;command&#34; : [ ],<br/>
        &#34;environment&#34; : [ ],<br/>
        &#34;mountPoints&#34; : [ ],<br/>
        &#34;volumesFrom&#34; : [ ],<br/>
        &#34;dependsOn&#34; : [ ],<br/>
        &#34;dnsServers&#34; : [ ],<br/>
        &#34;dnsSearchDomains&#34; : [ ],<br/>
        &#34;extraHosts&#34; : [ ],<br/>
        &#34;dockerSecurityOptions&#34; : [ ],<br/>
        &#34;ulimits&#34; : [ ],<br/>
        &#34;systemControls&#34; : [ ],<br/>
        &#34;resourceRequirements&#34; : [ ]<br/>
      },<br/>
    {<br/>
        &#34;name&#34; : &#34;${CONTAINER_NAME}_Sidecar&#34;,<br/>
        &#34;image&#34; : &#34;${DOCKER_IMAGE_NAME}&#34;,<br/>
        &#34;memory&#34; : &#34;512&#34;,<br/>
        &#34;portMappings&#34; : [ {<br/>
          &#34;containerPort&#34; : 85,<br/>
          &#34;protocol&#34; : &#34;tcp&#34;<br/>
        } ]<br/>
      } ],<br/>
      &#34;executionRoleArn&#34; : &#34;${EXECUTION_ROLE}&#34;,<br/>
      &#34;volumes&#34; : [ ],<br/>
      &#34;requiresAttributes&#34; : [ ],<br/>
      &#34;placementConstraints&#34; : [ ],<br/>
      &#34;compatibilities&#34; : [ ],<br/>
      &#34;requiresCompatibilities&#34; : [ ],<br/>
      &#34;cpu&#34; : &#34;512&#34;,<br/>
      &#34;memory&#34; : &#34;1024&#34;,<br/>
      &#34;inferenceAccelerators&#34; : [ ]<br/>
    }<br/>
    </pre>
    </details></div><div class="note-callout">Using <code>${CONTAINER_NAME}_Sidecar</code> isn&#39;t something you would do in production. It&#39;s just a simple way to try out the feature yourself. We include an advanced example later in this topic.  </div><p>Once the Service is deployed, you will see both containers in the ECS console:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587159319621/image.png"/></figure><p></p><p>You can use specs that deploy the Main Container and sidecars.</p><p></p><p></p><div class="hd--md" data-hd-markdown="&lt;details&gt;
      &lt;summary style=&#34;font-size: 1.25rem;outline: none;border: none; color: #00adea; margin-bottom:20px&#34;&gt;Here&#39;s an advanced example that deploys the Main Container, Nginx, and Tomcat:&lt;/summary&gt;

    &lt;pre&gt;
    {
      &#34;containerDefinitions&#34; : [ {
        &#34;name&#34; : &#34;${CONTAINER_NAME}&#34;,
        &#34;image&#34; : &#34;${DOCKER_IMAGE_NAME}&#34;,
        &#34;memory&#34; : 1024,
        &#34;links&#34; : [ ],
        &#34;portMappings&#34; : [ ],
        &#34;entryPoint&#34; : [ ],
        &#34;command&#34; : [ ],
        &#34;environment&#34; : [ ],
        &#34;mountPoints&#34; : [ ],
        &#34;volumesFrom&#34; : [ ],
        &#34;dependsOn&#34; : [ ],
        &#34;dnsServers&#34; : [ ],
        &#34;dnsSearchDomains&#34; : [ ],
        &#34;extraHosts&#34; : [ ],
        &#34;dockerSecurityOptions&#34; : [ ],
        &#34;ulimits&#34; : [ ],
        &#34;systemControls&#34; : [ ],
        &#34;resourceRequirements&#34; : [ ]
      },
    {
      &#34;name&#34;: &#34;nginx&#34;,
      &#34;image&#34;: &#34;nginx:latest&#34;,
      &#34;memory&#34;: 256,
      &#34;essential&#34;: true,
      &#34;portMappings&#34;: [
        {
          &#34;containerPort&#34;: 8181,
          &#34;protocol&#34;: &#34;tcp&#34;
        }
      ]
    },
    {
      &#34;essential&#34;: true,
      &#34;name&#34;: &#34;tomcat-webserver&#34;,
      &#34;image&#34;: &#34;tomcat&#34;,
      &#34;memory&#34;: 512,
      &#34;portMappings&#34;: [
          {
              &#34;hostPort&#34;: 91,
              &#34;containerPort&#34;: 9191,
              &#34;protocol&#34;: &#34;tcp&#34;
          }
      ]
    }
       ],
      &#34;executionRoleArn&#34; : &#34;${EXECUTION_ROLE}&#34;,
      &#34;volumes&#34; : [ ],
      &#34;requiresAttributes&#34; : [ ],
      &#34;placementConstraints&#34; : [ ],
      &#34;compatibilities&#34; : [ ],
      &#34;requiresCompatibilities&#34; : [ ],
      &#34;inferenceAccelerators&#34; : [ ],
      &#34;cpu&#34;: 1024
    }
    &lt;/pre&gt;
    &lt;/details&gt;"><details>
      <summary style="font-size: 1.25rem;outline: none;border: none; color: #00adea; margin-bottom:20px">Here&#39;s an advanced example that deploys the Main Container, Nginx, and Tomcat:</summary>
    <pre><br/>
    {<br/>
      &#34;containerDefinitions&#34; : [ {<br/>
        &#34;name&#34; : &#34;${CONTAINER_NAME}&#34;,<br/>
        &#34;image&#34; : &#34;${DOCKER_IMAGE_NAME}&#34;,<br/>
        &#34;memory&#34; : 1024,<br/>
        &#34;links&#34; : [ ],<br/>
        &#34;portMappings&#34; : [ ],<br/>
        &#34;entryPoint&#34; : [ ],<br/>
        &#34;command&#34; : [ ],<br/>
        &#34;environment&#34; : [ ],<br/>
        &#34;mountPoints&#34; : [ ],<br/>
        &#34;volumesFrom&#34; : [ ],<br/>
        &#34;dependsOn&#34; : [ ],<br/>
        &#34;dnsServers&#34; : [ ],<br/>
        &#34;dnsSearchDomains&#34; : [ ],<br/>
        &#34;extraHosts&#34; : [ ],<br/>
        &#34;dockerSecurityOptions&#34; : [ ],<br/>
        &#34;ulimits&#34; : [ ],<br/>
        &#34;systemControls&#34; : [ ],<br/>
        &#34;resourceRequirements&#34; : [ ]<br/>
      },<br/>
    {<br/>
      &#34;name&#34;: &#34;nginx&#34;,<br/>
      &#34;image&#34;: &#34;nginx:latest&#34;,<br/>
      &#34;memory&#34;: 256,<br/>
      &#34;essential&#34;: true,<br/>
      &#34;portMappings&#34;: [<br/>
        {<br/>
          &#34;containerPort&#34;: 8181,<br/>
          &#34;protocol&#34;: &#34;tcp&#34;<br/>
        }<br/>
      ]<br/>
    },<br/>
    {<br/>
      &#34;essential&#34;: true,<br/>
      &#34;name&#34;: &#34;tomcat-webserver&#34;,<br/>
      &#34;image&#34;: &#34;tomcat&#34;,<br/>
      &#34;memory&#34;: 512,<br/>
      &#34;portMappings&#34;: [<br/>
          {<br/>
              &#34;hostPort&#34;: 91,<br/>
              &#34;containerPort&#34;: 9191,<br/>
              &#34;protocol&#34;: &#34;tcp&#34;<br/>
          }<br/>
      ]<br/>
    }<br/>
       ],<br/>
      &#34;executionRoleArn&#34; : &#34;${EXECUTION_ROLE}&#34;,<br/>
      &#34;volumes&#34; : [ ],<br/>
      &#34;requiresAttributes&#34; : [ ],<br/>
      &#34;placementConstraints&#34; : [ ],<br/>
      &#34;compatibilities&#34; : [ ],<br/>
      &#34;requiresCompatibilities&#34; : [ ],<br/>
      &#34;inferenceAccelerators&#34; : [ ],<br/>
      &#34;cpu&#34;: 1024<br/>
    }<br/>
    </pre>
    </details></div><p>You can see that this example uses the <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#container_definition_image" target="_blank">default public Docker Hub setting for the container image</a>. You can also use a local repo.</p><div class="note-callout">Harness does not pull these images. They are pulled by ECS.</div><p>You can see all three container in the ECS console:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587163968510/image.png"/></figure><p>That&#39;s all you have to do to deploy sidecar containers. Use the Harness Service with a Harness Basic, Canary, or Blue/Green ECS Workflow and all of the containers are deployed.</p><h3>Step 2: Identify Main Container by Tag in ECS Console</h3><p>In a Harness ECS deployment, the container that points to the main artifact being deployed is called the Main Container.</p><p>In the container spec, the <code>${CONTAINER_NAME}</code> and <code>${DOCKER_IMAGE_NAME}</code> placeholders identifies the Main Container. At deployment runtime, the placeholder is replaced with a name generated using the artifact name.</p><p>When you add verification steps to the <strong>Verify</strong> section of your Harness Workflow, Harness performs verification on your Main Container only. The sidecar containers are not verified using Harness <a href="/article/ina58fap5y-what-is-cv">Continuous Verification</a>.</p><p>The Main Container is identified by Harness using the AWS Tag <strong>HARNESS_DEPLOYED_MAIN_CONTAINER</strong>.</p><p>The <code>key:value</code> for the tag is <code>HARNESS_DEPLOYED_MAIN_CONTAINER:&lt;Container_Name&gt;</code>.</p><p>You can see this tag in the ECS console.</p><p>Locate the ECS service you deployed, and then click its <strong>Task definition</strong>.</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587159223676/image.png"/></figure><p>In the task definition, in the <strong>Builder</strong> tab, in <strong>Container Definitions</strong>, you can see the containers that were deployed:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587159319621/image.png"/></figure><p>In the task definition <strong>Tags</strong> tab, you can see the Main Container tag that displays the name of the Main Container:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587159400822/image.png"/></figure><p></p><div class="warning-callout">Do not edit or remove this tag.</div><p>You will see the same Main Container tag when you deploy multiple sidecar containers also:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587164153705/image.png"/></figure><p></p><h3>Option: Using Workflow Variables in Container Specs</h3><p>In the container spec, the <code>${CONTAINER_NAME}</code> and <code>${DOCKER_IMAGE_NAME}</code> placeholders identifies the Main Container. These placeholders must be present.</p><p>For the sidecar specs, you can hardcode the name and image values, or you can use Harness <a href="/article/766iheu1bk-add-workflow-variables-new-template">Workflow variable expressions</a>.</p><p>When you use Workflow variable expressions, you provide the values for the spec when the Workflow is deployed.</p><p>This is one way to template the ECS sidecar container specs.</p><p>Let&#39;s look at a Harness ECS Workflow with Workflow variables for two sidecar containers:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587165082085/image.png"/></figure><p>Now let&#39;s look at how these are used in the sidecar container specs in a Harness Service:</p><pre>...<br/>{<br/>  &#34;name&#34;: &#34;${workflow.variables.Sidecar1Name}&#34;,<br/>  &#34;image&#34;: &#34;${workflow.variables.Sidecar1Image}&#34;,<br/>  &#34;memory&#34;: 256,<br/>  &#34;essential&#34;: true,<br/>  &#34;portMappings&#34;: [<br/>    {<br/>      &#34;containerPort&#34;: 8181,<br/>      &#34;protocol&#34;: &#34;tcp&#34;<br/>    }<br/>  ]<br/>},<br/>{<br/>  &#34;essential&#34;: true,<br/>  &#34;name&#34;: &#34;${workflow.variables.Sidecar2Name}&#34;,<br/>  &#34;image&#34;: &#34;${workflow.variables.Sidecar2Image}&#34;,<br/>  &#34;memory&#34;: 512,<br/>  &#34;portMappings&#34;: [<br/>      {<br/>          &#34;hostPort&#34;: 91,<br/>          &#34;containerPort&#34;: 9191,<br/>          &#34;protocol&#34;: &#34;tcp&#34;<br/>      }<br/>  ]<br/>}<br/>...</pre><p>When the Workflow is deployed, you are prompted to provide values for the Workflow variables used in the Service&#39;s container specs:</p><p></p><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/2eyw6epug0/1587165591262/image.png"/></figure><p>During deployment, the values you provided for the Workflow variables replace the Workflow variable expressions in the Service&#39;s container specs.</p><h3>Notes</h3><p>The following notes discuss important related information.</p><h4>Steady State</h4><p>Harness deploys and verifies steady state at the ECS task level, not the container level.</p><p>But if the task is running in a steady state, then its containers are also in a steady state.</p><p>If a single container fails, the task fails.</p><h4>Display Host and Container Information</h4><p>You can use <a href="/article/9dvxcegm90-variables">Harness built-inn variables expressions</a> and a <a href="/article/1fjrjbau7x-capture-shell-script-step-output">Shell Script</a> step in your Workflow to display useful information about the deployed containers and hosts.</p><p>Here is an example:</p><pre>echo instance.hostName: ${instance.hostName}<br/><br/>echo instance.host.hostName: ${instance.host.hostName}<br/><br/>echo instance.host.ip: ${instance.host.ip}<br/><br/>echo instance.EcsContainerDetails.dockerId: ${instance.EcsContainerDetails.dockerId}<br/><br/>echo instance.EcsContainerDetails.completeDockerId: ${instance.EcsContainerDetails.completeDockerId}<br/><br/>echo ec2Instance.privateIpAddress: ${instance.host.ec2Instance.privateIpAddress}</pre><h3>Next Steps</h3><ul><li> <a href="/article/9dvxcegm90-variables#aws_ecs">Harness built-in AWS ECS variable expressions</a>.</li></ul><p></p>
  slug: deploy-multiple-containers-in-a-single-ecs-workflow
  tags: []
  is_live: true
