<p>This topic describes how the SDKs communicate with Harness Feature Flags to receive flag changes.</p><h3>Visual summary</h3><details><summary>A summary of the communication between the Feature Flag SDKs and the Feature Flag client</summary><div><figure><img src="https://files.helpdocs.io/kw8ldg1itf/articles/7ikyqtmjce/1660658414633/ff-flowchart.jpeg" alt="A flow chart showing the communication strategy between Feature Flag SDKs and the Feature Flag Client."/></figure><p>The above diagram explains the flow a Feature Flag follows to Evaluate the Target. It can be explained by using several use cases:</p><h4>Feature Flag with no Rules and no Prerequisites</h4><p><strong>Flag Type:</strong> Boolean</p><p><strong>Flag state:</strong> ON</p><ol><li>If the Flag is ON, check for any prerequisites, and additional rules.  If there are none, the default ON variation is returned, which in the above example is ‘True’.</li><li>Is the Flag OFF, no rules are ever evaluated, and it returns the default OFF variation.  In the above example this is ‘False’</li></ol><h4>Feature Flag with Variation Target Mapping</h4><p><strong>Flag Type:</strong> Boolean</p><p><strong>Flag state:</strong> ON</p><p>The flag is ON, with target mapping.  This rule says serve False to target ‘xxxx’. </p><p>This implies that if the user evaluating the flag is ‘xxxx’ they&#39;ll receive a False variation.  Everyone else will receive ‘True’ variation.</p></div></details><h3>How do the SDKs Communicate with Feature Flags?</h3><p>The SDK maintains all the Feature Flag details locally in its cache and evaluates Flags based on it. The SDKs use streaming and a polling strategy to keep the local cache in sync with the flag configurations.</p><h4>Streaming</h4><p>Streaming provides a persistent connection to the SDKs. Harness Feature Flags uses <a href="https://en.wikipedia.org/wiki/Server-sent_events" target="_blank">Server-Sent Events</a> to send messages to the servers whenever the feature flag rules change. This has the following benefits:</p><ul><li>Updates flag in a few hundred milliseconds.</li><li>Avoids any delays by delivering real-time updates to end-users/targets. </li><li>Ensures that every change that is made is dispersed to every user in real-time propagating them across every server.</li></ul><h4>Polling</h4><p>In polling mode, you can define the interval of time at which you want to receive updates of Flag states from the Feature Flag. The SDK will then make HTTP requests to Feature Flags to retrieve flag state changes.</p><div class="note-callout">It is important to know that the Harness Feature Flag does not send any information as part of these requests, it is simply a query to update the status of a flag on the SDK side.</div><h4>Communication loop between Harness and the SDKs</h4><p></p><table><tbody><tr><td><p>Server-side</p></td><td><p>Client-side</p></td></tr><tr><td><p>The client authenticates with a server using an API Key.</p></td><td><p>The client authenticates with a server using an API key. The client is initialized for a specific target.</p></td></tr><tr><td><p>Configuration is fetched and cached in the memory.</p></td><td><p>All the Flag evaluations are fetched from the server and cached locally.</p></td></tr><tr><td><p>·  One call to fetch all Feature Flag configurations for the environment.</p><p>·  One call to fetch all Target Group configurations for the environment.</p><p> </p></td><td><p>Stream is opened to the server.</p><p> </p></td></tr><tr><td><p>In the case of streaming mode, a connection is open to the stream endpoint.</p></td><td><p>·  On any change in flag, an event is pushed to the SDK.</p><p>·  SDK fetches the flag value and caches it locally.</p></td></tr><tr><td><p>In case of polling mode:</p><p>Config is polled periodically (default 60 seconds), and the cache is updated.</p><p> </p></td><td><p> </p></td></tr><tr><td><p>All the evaluations are run against the cached data.</p></td><td><p> </p></td></tr></tbody></table><p></p>