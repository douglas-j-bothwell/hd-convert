type: article
article_id: g3m7pjq79y
user_id: xwmdbyp4x8
category_id: 99m8m1s55y
author:
  name: Doug Bothwell
  email: douglas.bothwell@harness.io
  profile_image: https://www.gravatar.com/avatar/120de2cc624d7903cf3d83b86d0f1b5e?d=mm&s=150
title: Optimizing CI Build Times
slug: optimizing-ci-build-times
description: You can use the following methods to speed up your CI builds. Test Intelligence.
  Testing is an important part of Continuous Integration. Testing safeguards the quality
  of your product before shipping…
short_version: You can use the following methods to speed up your CI builds. Test
  Intelligence. Testing is an important part of Continuous Integration. Testing safeguards
  the quality of your product before shipping…
tags: []
show_toc: true
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: ""
  source: API
  triggered_at: 2022-08-15T17:05:12.990693Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Optimizing CI Build Times
  description: ""
  short_version: ""
  body: <p>You can use the following methods to speed up your CI builds.</p><h3>Test
    Intelligence</h3><p>Testing is an important part of Continuous Integration. Testing
    safeguards the quality of your product before shipping. But testing can also take
    a lot of time because a test cycle involves multiple tests. Often, the tests run
    are irrelevant to the code changes that triggered the build.</p><p><a href="https://ngdocs.harness.io/article/vtu9k1dsfa">Test
    Intelligence</a> dramatically improves test times by running only the tests required
    to confirm the quality of the code changes that triggered the CI Pipeline. </p><h3>Looping
    Strategies</h3><p><a href="https://docs.harness.io/article/eh4azj73m4" target="_blank">Looping
    strategies</a> enable you to run a Stage or Step multiple times with different
    inputs. This eliminates the need to copy the same Stage or Step for each variation
    you need. It also makes the Pipeline more readable, clean, and easy to maintain.
    Looping strategies enable use cases such as:</p><ul><li>You want to test a UI
    feature in multiple browsers and platforms. You can define a matrix that specifies
    the browsers and platforms to test.</li><li>You want to build artifacts for multiple
    JDK versions in the same Build Stage.</li><li>You have a Build Pipeline with 20
    unit tests. To speed up execution, you want to run the tests in parallel across
    4 jobs that run 5 tests each.</li></ul><h3>Optimize Docker Images to Reduce Build
    Times</h3><p>The following practices can reduce your build times significantly: </p><ul><li>Pre-build
    images that include all required dependencies. If most of the build time is spent
    downloading dependencies, you sh ould pre-build an image with all required dependencies
    in a separate pipeline. Set up a periodic pipeline that builds the image with
    all the latest dependencies and pushes it to the registry. This image will be
    used by all the build pipelines.<br/>Pre-building images with all required dependencies
    is more efficient than downloading them to a baseline image as part of the Build
    setup. This is especially true if you update your images often to ensure that
    they include all the latest updates. </li><li>Exclude unnecessary files and packages
    from your images. In addition to reducing build times, this makes the resulting
    images smaller, simpler, and more portable. You can use <a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">dockerignore</a>
    files to exclude unnecessary files and folders from your images. </li><li>Sort
    multi-line arguments in your Dockerfile alphabetically. This makes it easier to
    update and avoid duplicate packages. </li></ul><p>For more best practices, see
    <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best
    Practices for Writing Dockerfiles</a> in the Docker documentation.</p><h3>Enable
    Docker Layer Caching in Build Steps</h3><p>Remote Docker Layer Caching can dramatically
    improve build times by sharing layers across Pipelines, Stages, and Steps. You
    can set up Docker Layer Caching in the following Build Steps:</p><ul><li><a href="https://ngdocs.harness.io/article/q6fr5bj63w-build-and-push-to-docker-hub-step-settings#remote_cache_repository">Build
    and Push to Docker Registry</a></li><li><a href="https://ngdocs.harness.io/article/aiqbxaef15-build-and-push-to-ecr-step-settings#sort=relevancy">Build
    and Push to ECR</a></li><li><a href="https://ngdocs.harness.io/article/66ykcm0sf0-build-and-push-to-gcr-step-settings#remote_cache_image">Build
    and Push to GCR</a></li></ul><h3>Optimize your Build Tests</h3><p>The following
    practices can reduce your testing and resulting build times:</p><ul><li>Use mock
    services in your unit tests, rather than setting up and connecting to third-party
    services. Mockups can often test your code as well as fully-running services but
    with fewer resources.</li><li>Avoid integration tests in your build pipelines
    when possible. You might want to move these to a separate Pipeline.</li><li>Look
    for obsolete tests that you can delete.</li><li>Look for unnecessary <code>sleep</code>
    statements in your unit test code.</li><li>Order your tests so that the tests
    most likely to fail come first.</li></ul><h3>Cache and Reuse the Data for Your
    Fetch Operations</h3><p>Caching and reusing can be useful for data that your builds
    need to fetch, but that you cannot include in an optimized image as described
    above. Caching ensures faster job execution by reusing the expensive fetch operation
    data from previous jobs. See the following for end-to-end-workflow descriptions:  </p><ul><li><a
    href="https://harness.io/blog/continuous-integration/harness-cie-ui-builds/" target="_blank">Harness
    CI for UI Builds</a></li><li><a href="https://ngdocs.harness.io/article/qibyllcmza">Save
    and Restore Cache from S3</a></li><li><a href="https://ngdocs.harness.io/article/v0agy0hlyj">Save
    and Restore Cache from GCS</a></li></ul><h3>Increase Step Resources </h3><p>If
    you still find that your builds are taking too long, check your infrastructure
    monitoring tools for potential bottlenecks during the time windows when your builds
    are running. Increasing memory or CPU capacity in your Build Steps might help
    speed up your builds. </p>
  slug: optimizing-ci-build-times
  tags: []
  is_live: true
