type: article
article_id: vo4sjbd09g
user_id: mfr0nxh4be
category_id: 4xo13zdnfx
author:
  name: Michael Cretzman
  email: michael.cretzman@harness.io
  profile_image: https://www.gravatar.com/avatar/2e8616837f4ee92be5d19ffe9b9ccba9?d=mm&s=150
title: Configure Service Dependency Step Settings
slug: configure-service-dependency-step-settings
description: 'A Service Dependency is a detached service that''s accessible to all
  Steps in a Stage. Service dependencies support workflows such as Integration testing:
  You can set up a service and then run tests a…'
short_version: 'A Service Dependency is a detached service that''s accessible to all
  Steps in a Stage. Service dependencies support workflows such as Integration testing:
  You can set up a service and then run tests a…'
tags: []
show_toc: true
is_private: false
is_published: true
is_featured: false
stale_status:
  is_stale: false
  reason: ""
  source: API
  triggered_at: 2022-05-05T12:07:04.366537Z
  expires_at: null
permission_groups: []
multilingual:
- language_code: en
  title: Configure Service Dependency Step Settings
  description: ""
  short_version: ""
  body: '<p>A <em>Service Dependency</em> is a detached service that&#39;s accessible
    to all Steps in a Stage. Service dependencies support workflows such as</p><ul><li>Integration
    testing: You can set up a service and then run tests against this service.</li><li>Running
    Docker-in-Docker: You can <a href="https://ngdocs.harness.io/article/ajehk588p4">set
    up a dind service</a> to process Docker commands in Run Steps.</li></ul><p>This
    topic provides settings and permissions for the Configure Service Dependency step.</p><h3>Before
    You Begin</h3><h4>Good Practice: Add a Health Check to Verify that the Service
    is Up</h4><p>After a container starts, the software running inside the container
    takes time to initialize and begin accepting requests. Before you send the first
    request, add a health check to verify that the service is running. You can add
    a <code>sleep</code> command to a Run Step, or implement a simple <code>while</code>
    loop to make the Step wait until the service is up. For example, if your Stage
    uses a dind step, you can run the following:</p><pre class="hljs bash">while !
    docker ps ;do <br/>     echo &#34;Docker not available yet&#34;<br/>done</pre><p></p><h4>Service
    and Step Networking</h4><p>Service and Step containers within the same Stage all
    share the same network. To communicate with a Service, use the local-host address
    and the port number defined in the Docker image. For example, you can use <code>127.0.0.1:6379</code>
    to communicate with a Redis server or <code>localhost:27017</code> to communicate
    with a Mongo database (assuming the default ports aren&#39;t overridden).</p><p>In
    a Kubernetes build infrastructure, all Steps run in Containers. In an AWS build
    infrastructure, some Steps might run directly on the VM. See <a href="#port_bindings">Port
    Bindings</a> below.</p><h3>Name</h3><p>The unique name for this step.</p><h3>ID</h3><p>See
    <a href="/article/li0my8tcz3-entity-identifier-reference" target="_blank">Entity
    Identifier Reference</a>.</p><h3>Description</h3><p>Text string.</p><h3>Container
    Registry</h3><p>Harness Connector for the container registry containing the Service
    Dependency image, such as DockerHub.</p><h3>Image</h3><p>The name of the Docker
    image.</p><p>The image name should include the tag and will default to the latest
    tag if unspecified.</p><p>You can use any Docker image from any Docker registry,
    including Docker images from private registries.</p><p>Example: <code>mysql:5</code></p><h3
    id="undefined">Optional Configurations</h3><h4>Privileged</h4><p>Enable this option
    to run the container with escalated privileges. This is the equivalent of running
    a container with the Docker <code>--privileged</code> flag.</p><h4>Environment
    Variables</h4><p>Add any environment variables you want to inject into the container.</p><h4>Entry
    Point</h4><p>ENTRYPOINT instructions allow you to configure a container that will
    run as an executable.</p><p>You can add commands in Entry Point to override the
    image <a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank">ENTRYPOINT</a>.
    See ENTRYPOINT best practices from Docker.</p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/vo4sjbd09g/1610057502164/image.png"/></figure><p>Commands
    should be in exec form.</p><p>Each command and parameter should be added separately.
    For example:</p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/vo4sjbd09g/1610057413349/image.png"/></figure><p>For
    a useful summary of ENTRYPOINT and CMD see <a href="https://aws.amazon.com/blogs/opensource/demystifying-entrypoint-cmd-docker/"
    target="_blank">Demystifying ENTRYPOINT and CMD in Docker</a> from AWS.</p><h4>Arguments</h4><p>Overrides
    the image <a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank">CMD</a>.
    Each argument should be in exec format. For example:</p><figure><img src="https://files.helpdocs.io/i5nl071jo5/articles/vo4sjbd09g/1610057506099/image.png"
    style="display:block;margin-left:0;margin-right:auto" data-hd-align="left"/></figure><p>For
    a useful summary of ENTRYPOINT and CMD, see <a href="https://aws.amazon.com/blogs/opensource/demystifying-entrypoint-cmd-docker/"
    target="_blank">Demystifying ENTRYPOINT and CMD in Docker</a> in the AWS docs.</p><h4
    id="port_bindings">Port Bindings</h4><p>When a Pipeline runs in an AWS build infrastructure,
    some Steps might run on a bare metal VM and others run in a container. The port
    used to communicate with the Service Dependency depends on where the Step is running:
    bare-metal Steps use the Host Port and containerized Steps use the Container Port.</p><p>Suppose
    you create a Service Dependency with the Name and Id <strong>myloginservice</strong>.</p><p>-
    A containerized Step talks to the service using <strong>myloginservice:</strong><em><strong>container_port</strong></em>.</p><p>-
    A Run or Run Test Step that runs directly on the VM talks to the service using
    <strong>localhost:</strong><em><strong>host_port</strong></em>.</p><p>The binding
    of Host and Container Ports is similar to <a href="https://docs.docker.com/config/containers/container-networking/"
    target="_blank">port mapping in Docker</a>. Usually the ports are the same unless
    the default Host Port for the service dependency is already in use by another
    local service.</p><h4>Image Pull Policy</h4><p>Select an option to set the pull
    policy for the image.</p><ul><li><strong>Always</strong>: The kubelet queries
    the container image registry to resolve the name to an image digest every time
    the kubelet launches a container. If the kubelet encounters an exact digest cached
    locally, it uses its cached image; otherwise, the kubelet downloads (pulls) the
    image with the resolved digest, and uses that image to launch the container.</li><li><strong>If
    Not Present</strong>: The image is pulled only if it isn&#39;t already present
    locally.</li><li><strong>Never</strong>: The image is assumed to exist locally.
    The kubelet doesn&#39;t try to pull the image.</li></ul><h4>Run as User</h4><p>Set
    the value to specify the user id for all processes in the pod, running in containers.
    See <a href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod">Set
    the security context for a pod</a>.</p><h4>Set container resources</h4><p>These
    settings specify the maximum resources used by the container at runtime.</p><h5>Limit
    Memory</h5><p>Maximum memory that the container can use. You can express memory
    as a plain integer or as a fixed-point number using the suffixes <code>G</code>
    or <code>M</code>. You can also use the power-of-two equivalents <code>Gi</code>
    and <code>Mi</code>.</p><h5>Limit CPU</h5><p>The maximum number of cores that
    the container can use. CPU limits are measured in cpu units. Fractional requests
    are allowed: you can specify one hundred millicpu as <code>0.1</code> or <code>100m</code>.
    See <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes"
    target="_blank">Resource units in Kubernetes</a>.</p><h5>Timeout</h5><p>Timeout
    for the step. Once the timeout is reached, the Step fails and the Pipeline execution
    continues.</p><h3>See Also</h3><ul><li><a href="https://ngdocs.harness.io/article/fbrgw2ixjr">Share
    CI Data across Steps and Stages</a></li><li><h2 id="run-docker-in-docker-in-a-ci-stage"><a
    href="https://ngdocs.harness.io/article/ajehk588p4">Run Docker-in-Docker in a
    CI Stage</a></h2></li></ul><p></p>'
  slug: configure-service-dependency-step-settings
  tags: []
  is_live: true
